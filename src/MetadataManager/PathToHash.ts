/*
 * Copyright (c) 2022 Samsung Electronics Co., Ltd. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import fs from 'fs';
import * as vscode from 'vscode';

import {generateHash} from '../Utils/Hash';
import {isOneExplorerTargetFile} from '../Utils/Helpers';

import {Metadata} from './Metadata';

// TODO: get this from Metadata
const METADATA_SAVEPATH: string = '.one-vscode/info/hash_objects';

class MetadataSynchronizer {
  static async run(flattenMap: any) {
    // 1. Create metadata if pathToHash exists but does not have actual metadata files,
    //    If pathToHash exists and there is a actual metadata file, but there is no path inside,
    //    create a path and data inside
    await this.createMetadata(flattenMap);

    // 2. Replace is_deleted with true for all metadata not in pathToHash
    await this.deleteMetadata(flattenMap);
  }

  static async createMetadata(flattenMap: any) {
    for (let path in flattenMap) {
      const hash = flattenMap[path];
      if (vscode.workspace.workspaceFolders) {
        await Metadata.createDefault(
            vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, path), hash);
      }
    }
  }

  static async deleteMetadata(flattenMap: any) {
    if (vscode.workspace.workspaceFolders === undefined ||
        !fs.existsSync(
            vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, METADATA_SAVEPATH)
                .fsPath)) {
      return;
    }
    const baseUri =
        vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, METADATA_SAVEPATH);
    const files = await vscode.workspace.fs.readDirectory(baseUri);
    for (const file of files) {
      const hashFolderUri = vscode.Uri.joinPath(baseUri, file[0]);
      const hashList = await vscode.workspace.fs.readDirectory(hashFolderUri);
      for (const hashFile of hashList) {
        const hashUri = vscode.Uri.joinPath(hashFolderUri, hashFile[0]);
        let metaObj =
            JSON.parse(Buffer.from(await vscode.workspace.fs.readFile(hashUri)).toString());
        const hash = file[0] + hashFile[0].split('.')[0];
        for (const path in metaObj) {
          if (flattenMap[path] === undefined) {
            const uri = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, path);
            await Metadata.disable(uri, hash);
          }
        }
      }
    }
  }
}



export class PathToHash {
  private static _instance: PathToHash;
  private _map: any;
  public static startFlag: boolean = false;

  private constructor() {}

  /**
   * A Singleton Object
   *
   * PathToHash is a data structure that stores the path of the actual data
   * and the hash value generated by the contents of the actual data
   * to synchronize the actual data and metadata
   */
  public static async getInstance() {
    if (!this._instance) {
      this._instance = new PathToHash();
      this._instance._map = await this._instance.init();
      PathToHash.startFlag = true;
    }
    return this._instance;
  }

  private async init() {
    if (vscode.workspace.workspaceFolders === undefined) {
      throw new Error('Need workspace');
    }
    const uri = vscode.workspace.workspaceFolders[0].uri;
    const map = await this.scanRecursively(uri);
    await MetadataSynchronizer.run(await this.getFlatMap(map));
    return map;
  }

  /**
   * Scan the file system and generates hash of all the files.
   * The map is structured as a tree of directories and files.
   *
   * @example
   *  uri: 'A/B/C.txt'
   *  return: {'A': {'B': {'C.txt': <C.txt's hash value> } } } }
   */
  private async scanRecursively(uri: vscode.Uri) {
    let subMap: {[key: string]: any} = {};
    const files = await vscode.workspace.fs.readDirectory(uri);

    for (const file of files) {
      const name: string = file[0];
      const type: vscode.FileType = file[1];

      if (type === vscode.FileType.File) {
        if (vscode.workspace.workspaceFolders !== undefined) {
          if (isOneExplorerTargetFile(
                  vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, name))) {
            subMap[name] = await generateHash(vscode.Uri.joinPath(uri, '/' + name));
          }
        }
      } else if (type === vscode.FileType.Directory && name !== METADATA_SAVEPATH.split('/')[0]) {
        const temp = await this.scanRecursively(vscode.Uri.joinPath(uri, '/' + name));
        if (temp !== undefined) {
          subMap[name] = temp;
        }
      }
    }
    if (Object.keys(subMap).length === 0) {
      return {};
    }

    return subMap;
  }

  private async getFlatMap(map: {[key: string]: any}) {
    if (vscode.workspace.workspaceFolders === undefined) {
      throw new Error('Need workspace');
    }
    let flatMap: any = {};
    let queue = [];
    for (let data in map) {
      queue.push([map[data], data.toString()]);
    }
    while (queue.length !== 0) {
      const node: any = queue.pop();
      const path = vscode.Uri.joinPath(vscode.workspace.workspaceFolders[0].uri, node[1]).fsPath;
      if (fs.lstatSync(path).isDirectory()) {
        for (let key in node[0]) {
          queue.push([node[0][key], node[1] + '/' + key]);
        }
      } else {
        flatMap[node[1]] = node[0];
      }
    }
    return flatMap;
  }


  /**
   * @brief Obtain a hash of the file of given 'uri' by searching in the map
   * @param uri the target file's uri
   * @returns string hash of the file. undefined if not found
   */
  getHash(uri: vscode.Uri) {
    const splitPath = vscode.workspace.asRelativePath(uri).split('/');
    let map = this._map;

    splitPath.forEach((path) => {
      if (map !== undefined) {
        map = map[path];
      }
    });

    return map;
  }

  /**
   * @brief Obtain a list of hashes of files in the directory of given 'uri', by searching in the
   * map
   * @param uri the target directory's uri
   * @example
   *  (workspace)
   *    dir/A.txt
   *       /B.txt
   *       /subdir/C.txt
   *  (return)
   *     [hash(A.txt), hash(B.txt), hash(C.txt)]
   * @returns A list of string hashs. An emtpy list if it's not a directory or is an empty
   *     directory.
   */
  getAllHashesUnderFolder(uri: vscode.Uri) {
    const folder = this.getHash(uri);
    const files: vscode.Uri[] = [];
    if (typeof (folder) === 'string') {
      // not a folder
      return files;
    }
    for (const name in folder) {
      if (typeof (folder[name]) === 'string') {
        files.push(vscode.Uri.joinPath(uri, name));
      } else {
        this.getAllHashesUnderFolder(vscode.Uri.joinPath(uri, name)).forEach(f => {
          files.push(f);
        });
      }
    }

    return files;
  }

  /**
   * @brief Input uri, extract path and hash values, and store them in a '_map'
   */
  async add(uri: vscode.Uri) {
    const splitPath = vscode.workspace.asRelativePath(uri).split('/');
    let content: any = await generateHash(uri);
    let subMap = this._map;
    let idx = 0;
    for (let path = splitPath[idx]; idx < splitPath.length - 1; path = splitPath[++idx]) {
      if (!subMap[path]) {
        subMap[path] = {};
      }
      subMap = subMap[path];
    }
    if (splitPath.length - 1 === idx) {
      // paths.length - 1: index of a file name
      // When all of the folder path are stored in pathToHash
      // update / create pathToHash for a file
      subMap[splitPath[idx]] = content;
      return;
    }

    for (let i = splitPath.length - 1; i > idx; --i) {
      let tempContent: {[key: string]: any} = {};
      tempContent[splitPath[i]] = content;
      content = tempContent;
    }
    subMap[splitPath[idx]] = content;
  }

  /**
   * @brief Input uri, extract path and hash values, and delete them in a '_map'
   */
  async delete(uri: vscode.Uri) {
    let subMap = this._map;
    const splitPath = vscode.workspace.asRelativePath(uri).split('/');

    for (let i = 0, name = splitPath[i]; i < splitPath.length - 1; name = splitPath[++i]) {
      if (!subMap) {
        return;
      }
      subMap = subMap[name];
    }
    if (subMap === undefined) {
      // already deleted
      return;
    }
    delete subMap[splitPath[splitPath.length - 1]];
    if (splitPath.length > 1) {
      await this.deleteEmptyDirPath(this._map, splitPath, 0);
    }
  }

  /**
   * @brief This function runs after deleting a particular file path from the '_map'
   * and deletes all empty directories up to the deleted file path.
   * To this end, the variable that recursively searches for '_map' is subMap,
   * and if 'subMap[splitPath[idx]]' is empty, it is deleted.
   */
  async deleteEmptyDirPath(subMap: any, splitPath: string[], idx: number) {
    const name = splitPath[idx];

    if (splitPath.length - 2 === idx) {
      if (subMap[name] !== undefined && Object.keys(subMap[name]).length === 0) {
        delete subMap[name];
      }
      return;
    }

    if (subMap[name] === undefined) {
      return;
    }

    await this.deleteEmptyDirPath(subMap[name], splitPath, idx + 1);
    if (subMap[name] !== undefined && Object.keys(subMap[name]).length === 0) {
      delete subMap[name];
    }
  }
}
