/*
 * Copyright (c) 2022 Samsung Electronics Co., Ltd. All Rights Reserved
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file is generated with
 * -
 * https://github.com/Samsung/ONE/blob/8e41a5031dabc9b6d265cdf1cd8dd8bba598c614/res/CircleSchema/0.4/circle_schema.fbs
 * - flatbuffers v2.0.7
 */

// automatically generated by the FlatBuffers compiler, do not modify
import * as flatbuffers from 'flatbuffers';


export enum TensorType {
  FLOAT32 = 0,
  FLOAT16 = 1,
  INT32 = 2,
  UINT8 = 3,
  INT64 = 4,
  STRING = 5,
  BOOL = 6,
  INT16 = 7,
  COMPLEX64 = 8,
  INT8 = 9,
  FLOAT64 = 10,
  COMPLEX128 = 11,
  UINT64 = 12,
  RESOURCE = 13,
  VARIANT = 14,
  UINT32 = 15
}

export enum QuantizationDetails {
  NONE = 0,
  CustomQuantization = 1
}

export function unionToQuantizationDetails(
    type: QuantizationDetails,
    accessor: (obj: CustomQuantization) => CustomQuantization | null): CustomQuantization|null {
  switch (QuantizationDetails[type]) {
    case 'NONE':
      return null;
    case 'CustomQuantization':
      return accessor(new CustomQuantization())! as CustomQuantization;
    default:
      return null;
  }
}

export function unionListToQuantizationDetails(
    type: QuantizationDetails,
    accessor: (index: number, obj: CustomQuantization) => CustomQuantization | null,
    index: number): CustomQuantization|null {
  switch (QuantizationDetails[type]) {
    case 'NONE':
      return null;
    case 'CustomQuantization':
      return accessor(index, new CustomQuantization())! as CustomQuantization;
    default:
      return null;
  }
}

export enum DimensionType {
  DENSE = 0,
  SPARSE_CSR = 1
}

export enum SparseIndexVector {
  NONE = 0,
  Int32Vector = 1,
  Uint16Vector = 2,
  Uint8Vector = 3
}

export function unionToSparseIndexVector(
    type: SparseIndexVector,
    accessor: (obj: Int32Vector|Uint16Vector|Uint8Vector) => Int32Vector | Uint16Vector |
        Uint8Vector | null): Int32Vector|Uint16Vector|Uint8Vector|null {
  switch (SparseIndexVector[type]) {
    case 'NONE':
      return null;
    case 'Int32Vector':
      return accessor(new Int32Vector())! as Int32Vector;
    case 'Uint16Vector':
      return accessor(new Uint16Vector())! as Uint16Vector;
    case 'Uint8Vector':
      return accessor(new Uint8Vector())! as Uint8Vector;
    default:
      return null;
  }
}

export function unionListToSparseIndexVector(
    type: SparseIndexVector,
    accessor: (index: number, obj: Int32Vector|Uint16Vector|Uint8Vector) =>
        Int32Vector | Uint16Vector | Uint8Vector | null,
    index: number): Int32Vector|Uint16Vector|Uint8Vector|null {
  switch (SparseIndexVector[type]) {
    case 'NONE':
      return null;
    case 'Int32Vector':
      return accessor(index, new Int32Vector())! as Int32Vector;
    case 'Uint16Vector':
      return accessor(index, new Uint16Vector())! as Uint16Vector;
    case 'Uint8Vector':
      return accessor(index, new Uint8Vector())! as Uint8Vector;
    default:
      return null;
  }
}

export enum BuiltinOperator {
  BCQ_GATHER = -4,
  BCQ_FULLY_CONNECTED = -3,
  INSTANCE_NORM = -2,
  ADD = 0,
  AVERAGE_POOL_2D = 1,
  CONCATENATION = 2,
  CONV_2D = 3,
  DEPTHWISE_CONV_2D = 4,
  DEPTH_TO_SPACE = 5,
  DEQUANTIZE = 6,
  EMBEDDING_LOOKUP = 7,
  FLOOR = 8,
  FULLY_CONNECTED = 9,
  HASHTABLE_LOOKUP = 10,
  L2_NORMALIZATION = 11,
  L2_POOL_2D = 12,
  LOCAL_RESPONSE_NORMALIZATION = 13,
  LOGISTIC = 14,
  LSH_PROJECTION = 15,
  LSTM = 16,
  MAX_POOL_2D = 17,
  MUL = 18,
  RELU = 19,
  RELU_N1_TO_1 = 20,
  RELU6 = 21,
  RESHAPE = 22,
  RESIZE_BILINEAR = 23,
  RNN = 24,
  SOFTMAX = 25,
  SPACE_TO_DEPTH = 26,
  SVDF = 27,
  TANH = 28,
  CONCAT_EMBEDDINGS = 29,
  SKIP_GRAM = 30,
  CALL = 31,
  CUSTOM = 32,
  EMBEDDING_LOOKUP_SPARSE = 33,
  PAD = 34,
  UNIDIRECTIONAL_SEQUENCE_RNN = 35,
  GATHER = 36,
  BATCH_TO_SPACE_ND = 37,
  SPACE_TO_BATCH_ND = 38,
  TRANSPOSE = 39,
  MEAN = 40,
  SUB = 41,
  DIV = 42,
  SQUEEZE = 43,
  UNIDIRECTIONAL_SEQUENCE_LSTM = 44,
  STRIDED_SLICE = 45,
  BIDIRECTIONAL_SEQUENCE_RNN = 46,
  EXP = 47,
  TOPK_V2 = 48,
  SPLIT = 49,
  LOG_SOFTMAX = 50,
  DELEGATE = 51,
  BIDIRECTIONAL_SEQUENCE_LSTM = 52,
  CAST = 53,
  PRELU = 54,
  MAXIMUM = 55,
  ARG_MAX = 56,
  MINIMUM = 57,
  LESS = 58,
  NEG = 59,
  PADV2 = 60,
  GREATER = 61,
  GREATER_EQUAL = 62,
  LESS_EQUAL = 63,
  SELECT = 64,
  SLICE = 65,
  SIN = 66,
  TRANSPOSE_CONV = 67,
  SPARSE_TO_DENSE = 68,
  TILE = 69,
  EXPAND_DIMS = 70,
  EQUAL = 71,
  NOT_EQUAL = 72,
  LOG = 73,
  SUM = 74,
  SQRT = 75,
  RSQRT = 76,
  SHAPE = 77,
  POW = 78,
  ARG_MIN = 79,
  FAKE_QUANT = 80,
  REDUCE_PROD = 81,
  REDUCE_MAX = 82,
  PACK = 83,
  LOGICAL_OR = 84,
  ONE_HOT = 85,
  LOGICAL_AND = 86,
  LOGICAL_NOT = 87,
  UNPACK = 88,
  REDUCE_MIN = 89,
  FLOOR_DIV = 90,
  REDUCE_ANY = 91,
  SQUARE = 92,
  ZEROS_LIKE = 93,
  FILL = 94,
  FLOOR_MOD = 95,
  RANGE = 96,
  RESIZE_NEAREST_NEIGHBOR = 97,
  LEAKY_RELU = 98,
  SQUARED_DIFFERENCE = 99,
  MIRROR_PAD = 100,
  ABS = 101,
  SPLIT_V = 102,
  UNIQUE = 103,
  CEIL = 104,
  REVERSE_V2 = 105,
  ADD_N = 106,
  GATHER_ND = 107,
  COS = 108,
  WHERE = 109,
  RANK = 110,
  ELU = 111,
  REVERSE_SEQUENCE = 112,
  MATRIX_DIAG = 113,
  QUANTIZE = 114,
  MATRIX_SET_DIAG = 115,
  ROUND = 116,
  HARD_SWISH = 117,
  IF = 118,
  WHILE = 119,
  NON_MAX_SUPPRESSION_V4 = 120,
  NON_MAX_SUPPRESSION_V5 = 121,
  SCATTER_ND = 122,
  SELECT_V2 = 123,
  DENSIFY = 124,
  SEGMENT_SUM = 125,
  BATCH_MATMUL = 126,
  PLACEHOLDER_FOR_GREATER_OP_CODES = 127,
  CUMSUM = 128,
  CALL_ONCE = 129,
  BROADCAST_TO = 130,
  RFFT2D = 131,
  CONV_3D = 132,
  IMAG = 133,
  REAL = 134,
  COMPLEX_ABS = 135,
  HASHTABLE = 136,
  HASHTABLE_FIND = 137,
  HASHTABLE_IMPORT = 138,
  HASHTABLE_SIZE = 139,
  REDUCE_ALL = 140,
  CONV_3D_TRANSPOSE = 141,
  VAR_HANDLE = 142,
  READ_VARIABLE = 143,
  ASSIGN_VARIABLE = 144,
  BROADCAST_ARGS = 145,
  RANDOM_STANDARD_NORMAL = 146
}

export enum BuiltinOptions {
  NONE = 0,
  Conv2DOptions = 1,
  DepthwiseConv2DOptions = 2,
  ConcatEmbeddingsOptions = 3,
  LSHProjectionOptions = 4,
  Pool2DOptions = 5,
  SVDFOptions = 6,
  RNNOptions = 7,
  FullyConnectedOptions = 8,
  SoftmaxOptions = 9,
  ConcatenationOptions = 10,
  AddOptions = 11,
  L2NormOptions = 12,
  LocalResponseNormalizationOptions = 13,
  LSTMOptions = 14,
  ResizeBilinearOptions = 15,
  CallOptions = 16,
  ReshapeOptions = 17,
  SkipGramOptions = 18,
  SpaceToDepthOptions = 19,
  EmbeddingLookupSparseOptions = 20,
  MulOptions = 21,
  PadOptions = 22,
  GatherOptions = 23,
  BatchToSpaceNDOptions = 24,
  SpaceToBatchNDOptions = 25,
  TransposeOptions = 26,
  ReducerOptions = 27,
  SubOptions = 28,
  DivOptions = 29,
  SqueezeOptions = 30,
  SequenceRNNOptions = 31,
  StridedSliceOptions = 32,
  ExpOptions = 33,
  TopKV2Options = 34,
  SplitOptions = 35,
  LogSoftmaxOptions = 36,
  CastOptions = 37,
  DequantizeOptions = 38,
  MaximumMinimumOptions = 39,
  ArgMaxOptions = 40,
  LessOptions = 41,
  NegOptions = 42,
  PadV2Options = 43,
  GreaterOptions = 44,
  GreaterEqualOptions = 45,
  LessEqualOptions = 46,
  SelectOptions = 47,
  SliceOptions = 48,
  TransposeConvOptions = 49,
  SparseToDenseOptions = 50,
  TileOptions = 51,
  ExpandDimsOptions = 52,
  EqualOptions = 53,
  NotEqualOptions = 54,
  ShapeOptions = 55,
  PowOptions = 56,
  ArgMinOptions = 57,
  FakeQuantOptions = 58,
  PackOptions = 59,
  LogicalOrOptions = 60,
  OneHotOptions = 61,
  LogicalAndOptions = 62,
  LogicalNotOptions = 63,
  UnpackOptions = 64,
  FloorDivOptions = 65,
  SquareOptions = 66,
  ZerosLikeOptions = 67,
  FillOptions = 68,
  BidirectionalSequenceLSTMOptions = 69,
  BidirectionalSequenceRNNOptions = 70,
  UnidirectionalSequenceLSTMOptions = 71,
  FloorModOptions = 72,
  RangeOptions = 73,
  ResizeNearestNeighborOptions = 74,
  LeakyReluOptions = 75,
  SquaredDifferenceOptions = 76,
  MirrorPadOptions = 77,
  AbsOptions = 78,
  SplitVOptions = 79,
  UniqueOptions = 80,
  ReverseV2Options = 81,
  AddNOptions = 82,
  GatherNdOptions = 83,
  CosOptions = 84,
  WhereOptions = 85,
  RankOptions = 86,
  ReverseSequenceOptions = 87,
  MatrixDiagOptions = 88,
  QuantizeOptions = 89,
  MatrixSetDiagOptions = 90,
  HardSwishOptions = 91,
  IfOptions = 92,
  WhileOptions = 93,
  DepthToSpaceOptions = 94,
  NonMaxSuppressionV4Options = 95,
  NonMaxSuppressionV5Options = 96,
  ScatterNdOptions = 97,
  SelectV2Options = 98,
  DensifyOptions = 99,
  SegmentSumOptions = 100,
  BatchMatMulOptions = 101,
  CumsumOptions = 102,
  CallOnceOptions = 103,
  BroadcastToOptions = 104,
  Rfft2dOptions = 105,
  Conv3DOptions = 106,
  HashtableOptions = 107,
  HashtableFindOptions = 108,
  HashtableImportOptions = 109,
  HashtableSizeOptions = 110,
  VarHandleOptions = 111,
  ReadVariableOptions = 112,
  AssignVariableOptions = 113,
  RandomOptions = 114,
  BCQGatherOptions = 252,
  BCQFullyConnectedOptions = 253,
  InstanceNormOptions = 254
}

export function unionToBuiltinOptions(
    type: BuiltinOptions,
    accessor: (
        obj: AbsOptions|AddNOptions|AddOptions|ArgMaxOptions|ArgMinOptions|AssignVariableOptions|
        BCQFullyConnectedOptions|BCQGatherOptions|BatchMatMulOptions|BatchToSpaceNDOptions|
        BidirectionalSequenceLSTMOptions|BidirectionalSequenceRNNOptions|BroadcastToOptions|
        CallOnceOptions|CallOptions|CastOptions|ConcatEmbeddingsOptions|ConcatenationOptions|
        Conv2DOptions|Conv3DOptions|CosOptions|CumsumOptions|DensifyOptions|DepthToSpaceOptions|
        DepthwiseConv2DOptions|DequantizeOptions|DivOptions|EmbeddingLookupSparseOptions|
        EqualOptions|ExpOptions|ExpandDimsOptions|FakeQuantOptions|FillOptions|FloorDivOptions|
        FloorModOptions|FullyConnectedOptions|GatherNdOptions|GatherOptions|GreaterEqualOptions|
        GreaterOptions|HardSwishOptions|HashtableFindOptions|HashtableImportOptions|
        HashtableOptions|HashtableSizeOptions|IfOptions|InstanceNormOptions|L2NormOptions|
        LSHProjectionOptions|LSTMOptions|LeakyReluOptions|LessEqualOptions|LessOptions|
        LocalResponseNormalizationOptions|LogSoftmaxOptions|LogicalAndOptions|LogicalNotOptions|
        LogicalOrOptions|MatrixDiagOptions|MatrixSetDiagOptions|MaximumMinimumOptions|
        MirrorPadOptions|MulOptions|NegOptions|NonMaxSuppressionV4Options|
        NonMaxSuppressionV5Options|NotEqualOptions|OneHotOptions|PackOptions|PadOptions|
        PadV2Options|Pool2DOptions|PowOptions|QuantizeOptions|RNNOptions|RandomOptions|RangeOptions|
        RankOptions|ReadVariableOptions|ReducerOptions|ReshapeOptions|ResizeBilinearOptions|
        ResizeNearestNeighborOptions|ReverseSequenceOptions|ReverseV2Options|Rfft2dOptions|
        SVDFOptions|ScatterNdOptions|SegmentSumOptions|SelectOptions|SelectV2Options|
        SequenceRNNOptions|ShapeOptions|SkipGramOptions|SliceOptions|SoftmaxOptions|
        SpaceToBatchNDOptions|SpaceToDepthOptions|SparseToDenseOptions|SplitOptions|SplitVOptions|
        SquareOptions|SquaredDifferenceOptions|SqueezeOptions|StridedSliceOptions|SubOptions|
        TileOptions|TopKV2Options|TransposeConvOptions|TransposeOptions|
        UnidirectionalSequenceLSTMOptions|UniqueOptions|UnpackOptions|VarHandleOptions|WhereOptions|
        WhileOptions|ZerosLikeOptions) => AbsOptions | AddNOptions | AddOptions | ArgMaxOptions |
        ArgMinOptions | AssignVariableOptions | BCQFullyConnectedOptions | BCQGatherOptions |
        BatchMatMulOptions | BatchToSpaceNDOptions | BidirectionalSequenceLSTMOptions |
        BidirectionalSequenceRNNOptions | BroadcastToOptions | CallOnceOptions | CallOptions |
        CastOptions | ConcatEmbeddingsOptions | ConcatenationOptions | Conv2DOptions |
        Conv3DOptions | CosOptions | CumsumOptions | DensifyOptions | DepthToSpaceOptions |
        DepthwiseConv2DOptions | DequantizeOptions | DivOptions | EmbeddingLookupSparseOptions |
        EqualOptions | ExpOptions | ExpandDimsOptions | FakeQuantOptions | FillOptions |
        FloorDivOptions | FloorModOptions | FullyConnectedOptions | GatherNdOptions |
        GatherOptions | GreaterEqualOptions | GreaterOptions | HardSwishOptions |
        HashtableFindOptions | HashtableImportOptions | HashtableOptions | HashtableSizeOptions |
        IfOptions | InstanceNormOptions | L2NormOptions | LSHProjectionOptions | LSTMOptions |
        LeakyReluOptions | LessEqualOptions | LessOptions | LocalResponseNormalizationOptions |
        LogSoftmaxOptions | LogicalAndOptions | LogicalNotOptions | LogicalOrOptions |
        MatrixDiagOptions | MatrixSetDiagOptions | MaximumMinimumOptions | MirrorPadOptions |
        MulOptions | NegOptions | NonMaxSuppressionV4Options | NonMaxSuppressionV5Options |
        NotEqualOptions | OneHotOptions | PackOptions | PadOptions | PadV2Options | Pool2DOptions |
        PowOptions | QuantizeOptions | RNNOptions | RandomOptions | RangeOptions | RankOptions |
        ReadVariableOptions | ReducerOptions | ReshapeOptions | ResizeBilinearOptions |
        ResizeNearestNeighborOptions | ReverseSequenceOptions | ReverseV2Options | Rfft2dOptions |
        SVDFOptions | ScatterNdOptions | SegmentSumOptions | SelectOptions | SelectV2Options |
        SequenceRNNOptions | ShapeOptions | SkipGramOptions | SliceOptions | SoftmaxOptions |
        SpaceToBatchNDOptions | SpaceToDepthOptions | SparseToDenseOptions | SplitOptions |
        SplitVOptions | SquareOptions | SquaredDifferenceOptions | SqueezeOptions |
        StridedSliceOptions | SubOptions | TileOptions | TopKV2Options | TransposeConvOptions |
        TransposeOptions | UnidirectionalSequenceLSTMOptions | UniqueOptions | UnpackOptions |
        VarHandleOptions | WhereOptions | WhileOptions | ZerosLikeOptions | null): AbsOptions|
    AddNOptions|AddOptions|ArgMaxOptions|ArgMinOptions|AssignVariableOptions|
    BCQFullyConnectedOptions|BCQGatherOptions|BatchMatMulOptions|BatchToSpaceNDOptions|
    BidirectionalSequenceLSTMOptions|BidirectionalSequenceRNNOptions|BroadcastToOptions|
    CallOnceOptions|CallOptions|CastOptions|ConcatEmbeddingsOptions|ConcatenationOptions|
    Conv2DOptions|Conv3DOptions|CosOptions|CumsumOptions|DensifyOptions|DepthToSpaceOptions|
    DepthwiseConv2DOptions|DequantizeOptions|DivOptions|EmbeddingLookupSparseOptions|EqualOptions|
    ExpOptions|ExpandDimsOptions|FakeQuantOptions|FillOptions|FloorDivOptions|FloorModOptions|
    FullyConnectedOptions|GatherNdOptions|GatherOptions|GreaterEqualOptions|GreaterOptions|
    HardSwishOptions|HashtableFindOptions|HashtableImportOptions|HashtableOptions|
    HashtableSizeOptions|IfOptions|InstanceNormOptions|L2NormOptions|LSHProjectionOptions|
    LSTMOptions|LeakyReluOptions|LessEqualOptions|LessOptions|LocalResponseNormalizationOptions|
    LogSoftmaxOptions|LogicalAndOptions|LogicalNotOptions|LogicalOrOptions|MatrixDiagOptions|
    MatrixSetDiagOptions|MaximumMinimumOptions|MirrorPadOptions|MulOptions|NegOptions|
    NonMaxSuppressionV4Options|NonMaxSuppressionV5Options|NotEqualOptions|OneHotOptions|PackOptions|
    PadOptions|PadV2Options|Pool2DOptions|PowOptions|QuantizeOptions|RNNOptions|RandomOptions|
    RangeOptions|RankOptions|ReadVariableOptions|ReducerOptions|ReshapeOptions|
    ResizeBilinearOptions|ResizeNearestNeighborOptions|ReverseSequenceOptions|ReverseV2Options|
    Rfft2dOptions|SVDFOptions|ScatterNdOptions|SegmentSumOptions|SelectOptions|SelectV2Options|
    SequenceRNNOptions|ShapeOptions|SkipGramOptions|SliceOptions|SoftmaxOptions|
    SpaceToBatchNDOptions|SpaceToDepthOptions|SparseToDenseOptions|SplitOptions|SplitVOptions|
    SquareOptions|SquaredDifferenceOptions|SqueezeOptions|StridedSliceOptions|SubOptions|
    TileOptions|TopKV2Options|TransposeConvOptions|TransposeOptions|
    UnidirectionalSequenceLSTMOptions|UniqueOptions|UnpackOptions|VarHandleOptions|WhereOptions|
    WhileOptions|ZerosLikeOptions|null {
  switch (BuiltinOptions[type]) {
    case 'NONE':
      return null;
    case 'Conv2DOptions':
      return accessor(new Conv2DOptions())! as Conv2DOptions;
    case 'DepthwiseConv2DOptions':
      return accessor(new DepthwiseConv2DOptions())! as DepthwiseConv2DOptions;
    case 'ConcatEmbeddingsOptions':
      return accessor(new ConcatEmbeddingsOptions())! as ConcatEmbeddingsOptions;
    case 'LSHProjectionOptions':
      return accessor(new LSHProjectionOptions())! as LSHProjectionOptions;
    case 'Pool2DOptions':
      return accessor(new Pool2DOptions())! as Pool2DOptions;
    case 'SVDFOptions':
      return accessor(new SVDFOptions())! as SVDFOptions;
    case 'RNNOptions':
      return accessor(new RNNOptions())! as RNNOptions;
    case 'FullyConnectedOptions':
      return accessor(new FullyConnectedOptions())! as FullyConnectedOptions;
    case 'SoftmaxOptions':
      return accessor(new SoftmaxOptions())! as SoftmaxOptions;
    case 'ConcatenationOptions':
      return accessor(new ConcatenationOptions())! as ConcatenationOptions;
    case 'AddOptions':
      return accessor(new AddOptions())! as AddOptions;
    case 'L2NormOptions':
      return accessor(new L2NormOptions())! as L2NormOptions;
    case 'LocalResponseNormalizationOptions':
      return accessor(new LocalResponseNormalizationOptions())! as
          LocalResponseNormalizationOptions;
    case 'LSTMOptions':
      return accessor(new LSTMOptions())! as LSTMOptions;
    case 'ResizeBilinearOptions':
      return accessor(new ResizeBilinearOptions())! as ResizeBilinearOptions;
    case 'CallOptions':
      return accessor(new CallOptions())! as CallOptions;
    case 'ReshapeOptions':
      return accessor(new ReshapeOptions())! as ReshapeOptions;
    case 'SkipGramOptions':
      return accessor(new SkipGramOptions())! as SkipGramOptions;
    case 'SpaceToDepthOptions':
      return accessor(new SpaceToDepthOptions())! as SpaceToDepthOptions;
    case 'EmbeddingLookupSparseOptions':
      return accessor(new EmbeddingLookupSparseOptions())! as EmbeddingLookupSparseOptions;
    case 'MulOptions':
      return accessor(new MulOptions())! as MulOptions;
    case 'PadOptions':
      return accessor(new PadOptions())! as PadOptions;
    case 'GatherOptions':
      return accessor(new GatherOptions())! as GatherOptions;
    case 'BatchToSpaceNDOptions':
      return accessor(new BatchToSpaceNDOptions())! as BatchToSpaceNDOptions;
    case 'SpaceToBatchNDOptions':
      return accessor(new SpaceToBatchNDOptions())! as SpaceToBatchNDOptions;
    case 'TransposeOptions':
      return accessor(new TransposeOptions())! as TransposeOptions;
    case 'ReducerOptions':
      return accessor(new ReducerOptions())! as ReducerOptions;
    case 'SubOptions':
      return accessor(new SubOptions())! as SubOptions;
    case 'DivOptions':
      return accessor(new DivOptions())! as DivOptions;
    case 'SqueezeOptions':
      return accessor(new SqueezeOptions())! as SqueezeOptions;
    case 'SequenceRNNOptions':
      return accessor(new SequenceRNNOptions())! as SequenceRNNOptions;
    case 'StridedSliceOptions':
      return accessor(new StridedSliceOptions())! as StridedSliceOptions;
    case 'ExpOptions':
      return accessor(new ExpOptions())! as ExpOptions;
    case 'TopKV2Options':
      return accessor(new TopKV2Options())! as TopKV2Options;
    case 'SplitOptions':
      return accessor(new SplitOptions())! as SplitOptions;
    case 'LogSoftmaxOptions':
      return accessor(new LogSoftmaxOptions())! as LogSoftmaxOptions;
    case 'CastOptions':
      return accessor(new CastOptions())! as CastOptions;
    case 'DequantizeOptions':
      return accessor(new DequantizeOptions())! as DequantizeOptions;
    case 'MaximumMinimumOptions':
      return accessor(new MaximumMinimumOptions())! as MaximumMinimumOptions;
    case 'ArgMaxOptions':
      return accessor(new ArgMaxOptions())! as ArgMaxOptions;
    case 'LessOptions':
      return accessor(new LessOptions())! as LessOptions;
    case 'NegOptions':
      return accessor(new NegOptions())! as NegOptions;
    case 'PadV2Options':
      return accessor(new PadV2Options())! as PadV2Options;
    case 'GreaterOptions':
      return accessor(new GreaterOptions())! as GreaterOptions;
    case 'GreaterEqualOptions':
      return accessor(new GreaterEqualOptions())! as GreaterEqualOptions;
    case 'LessEqualOptions':
      return accessor(new LessEqualOptions())! as LessEqualOptions;
    case 'SelectOptions':
      return accessor(new SelectOptions())! as SelectOptions;
    case 'SliceOptions':
      return accessor(new SliceOptions())! as SliceOptions;
    case 'TransposeConvOptions':
      return accessor(new TransposeConvOptions())! as TransposeConvOptions;
    case 'SparseToDenseOptions':
      return accessor(new SparseToDenseOptions())! as SparseToDenseOptions;
    case 'TileOptions':
      return accessor(new TileOptions())! as TileOptions;
    case 'ExpandDimsOptions':
      return accessor(new ExpandDimsOptions())! as ExpandDimsOptions;
    case 'EqualOptions':
      return accessor(new EqualOptions())! as EqualOptions;
    case 'NotEqualOptions':
      return accessor(new NotEqualOptions())! as NotEqualOptions;
    case 'ShapeOptions':
      return accessor(new ShapeOptions())! as ShapeOptions;
    case 'PowOptions':
      return accessor(new PowOptions())! as PowOptions;
    case 'ArgMinOptions':
      return accessor(new ArgMinOptions())! as ArgMinOptions;
    case 'FakeQuantOptions':
      return accessor(new FakeQuantOptions())! as FakeQuantOptions;
    case 'PackOptions':
      return accessor(new PackOptions())! as PackOptions;
    case 'LogicalOrOptions':
      return accessor(new LogicalOrOptions())! as LogicalOrOptions;
    case 'OneHotOptions':
      return accessor(new OneHotOptions())! as OneHotOptions;
    case 'LogicalAndOptions':
      return accessor(new LogicalAndOptions())! as LogicalAndOptions;
    case 'LogicalNotOptions':
      return accessor(new LogicalNotOptions())! as LogicalNotOptions;
    case 'UnpackOptions':
      return accessor(new UnpackOptions())! as UnpackOptions;
    case 'FloorDivOptions':
      return accessor(new FloorDivOptions())! as FloorDivOptions;
    case 'SquareOptions':
      return accessor(new SquareOptions())! as SquareOptions;
    case 'ZerosLikeOptions':
      return accessor(new ZerosLikeOptions())! as ZerosLikeOptions;
    case 'FillOptions':
      return accessor(new FillOptions())! as FillOptions;
    case 'BidirectionalSequenceLSTMOptions':
      return accessor(new BidirectionalSequenceLSTMOptions())! as BidirectionalSequenceLSTMOptions;
    case 'BidirectionalSequenceRNNOptions':
      return accessor(new BidirectionalSequenceRNNOptions())! as BidirectionalSequenceRNNOptions;
    case 'UnidirectionalSequenceLSTMOptions':
      return accessor(new UnidirectionalSequenceLSTMOptions())! as
          UnidirectionalSequenceLSTMOptions;
    case 'FloorModOptions':
      return accessor(new FloorModOptions())! as FloorModOptions;
    case 'RangeOptions':
      return accessor(new RangeOptions())! as RangeOptions;
    case 'ResizeNearestNeighborOptions':
      return accessor(new ResizeNearestNeighborOptions())! as ResizeNearestNeighborOptions;
    case 'LeakyReluOptions':
      return accessor(new LeakyReluOptions())! as LeakyReluOptions;
    case 'SquaredDifferenceOptions':
      return accessor(new SquaredDifferenceOptions())! as SquaredDifferenceOptions;
    case 'MirrorPadOptions':
      return accessor(new MirrorPadOptions())! as MirrorPadOptions;
    case 'AbsOptions':
      return accessor(new AbsOptions())! as AbsOptions;
    case 'SplitVOptions':
      return accessor(new SplitVOptions())! as SplitVOptions;
    case 'UniqueOptions':
      return accessor(new UniqueOptions())! as UniqueOptions;
    case 'ReverseV2Options':
      return accessor(new ReverseV2Options())! as ReverseV2Options;
    case 'AddNOptions':
      return accessor(new AddNOptions())! as AddNOptions;
    case 'GatherNdOptions':
      return accessor(new GatherNdOptions())! as GatherNdOptions;
    case 'CosOptions':
      return accessor(new CosOptions())! as CosOptions;
    case 'WhereOptions':
      return accessor(new WhereOptions())! as WhereOptions;
    case 'RankOptions':
      return accessor(new RankOptions())! as RankOptions;
    case 'ReverseSequenceOptions':
      return accessor(new ReverseSequenceOptions())! as ReverseSequenceOptions;
    case 'MatrixDiagOptions':
      return accessor(new MatrixDiagOptions())! as MatrixDiagOptions;
    case 'QuantizeOptions':
      return accessor(new QuantizeOptions())! as QuantizeOptions;
    case 'MatrixSetDiagOptions':
      return accessor(new MatrixSetDiagOptions())! as MatrixSetDiagOptions;
    case 'HardSwishOptions':
      return accessor(new HardSwishOptions())! as HardSwishOptions;
    case 'IfOptions':
      return accessor(new IfOptions())! as IfOptions;
    case 'WhileOptions':
      return accessor(new WhileOptions())! as WhileOptions;
    case 'DepthToSpaceOptions':
      return accessor(new DepthToSpaceOptions())! as DepthToSpaceOptions;
    case 'NonMaxSuppressionV4Options':
      return accessor(new NonMaxSuppressionV4Options())! as NonMaxSuppressionV4Options;
    case 'NonMaxSuppressionV5Options':
      return accessor(new NonMaxSuppressionV5Options())! as NonMaxSuppressionV5Options;
    case 'ScatterNdOptions':
      return accessor(new ScatterNdOptions())! as ScatterNdOptions;
    case 'SelectV2Options':
      return accessor(new SelectV2Options())! as SelectV2Options;
    case 'DensifyOptions':
      return accessor(new DensifyOptions())! as DensifyOptions;
    case 'SegmentSumOptions':
      return accessor(new SegmentSumOptions())! as SegmentSumOptions;
    case 'BatchMatMulOptions':
      return accessor(new BatchMatMulOptions())! as BatchMatMulOptions;
    case 'CumsumOptions':
      return accessor(new CumsumOptions())! as CumsumOptions;
    case 'CallOnceOptions':
      return accessor(new CallOnceOptions())! as CallOnceOptions;
    case 'BroadcastToOptions':
      return accessor(new BroadcastToOptions())! as BroadcastToOptions;
    case 'Rfft2dOptions':
      return accessor(new Rfft2dOptions())! as Rfft2dOptions;
    case 'Conv3DOptions':
      return accessor(new Conv3DOptions())! as Conv3DOptions;
    case 'HashtableOptions':
      return accessor(new HashtableOptions())! as HashtableOptions;
    case 'HashtableFindOptions':
      return accessor(new HashtableFindOptions())! as HashtableFindOptions;
    case 'HashtableImportOptions':
      return accessor(new HashtableImportOptions())! as HashtableImportOptions;
    case 'HashtableSizeOptions':
      return accessor(new HashtableSizeOptions())! as HashtableSizeOptions;
    case 'VarHandleOptions':
      return accessor(new VarHandleOptions())! as VarHandleOptions;
    case 'ReadVariableOptions':
      return accessor(new ReadVariableOptions())! as ReadVariableOptions;
    case 'AssignVariableOptions':
      return accessor(new AssignVariableOptions())! as AssignVariableOptions;
    case 'RandomOptions':
      return accessor(new RandomOptions())! as RandomOptions;
    case 'BCQGatherOptions':
      return accessor(new BCQGatherOptions())! as BCQGatherOptions;
    case 'BCQFullyConnectedOptions':
      return accessor(new BCQFullyConnectedOptions())! as BCQFullyConnectedOptions;
    case 'InstanceNormOptions':
      return accessor(new InstanceNormOptions())! as InstanceNormOptions;
    default:
      return null;
  }
}

export function unionListToBuiltinOptions(
    type: BuiltinOptions,
    accessor: (
        index: number,
        obj: AbsOptions|AddNOptions|AddOptions|ArgMaxOptions|ArgMinOptions|AssignVariableOptions|
        BCQFullyConnectedOptions|BCQGatherOptions|BatchMatMulOptions|BatchToSpaceNDOptions|
        BidirectionalSequenceLSTMOptions|BidirectionalSequenceRNNOptions|BroadcastToOptions|
        CallOnceOptions|CallOptions|CastOptions|ConcatEmbeddingsOptions|ConcatenationOptions|
        Conv2DOptions|Conv3DOptions|CosOptions|CumsumOptions|DensifyOptions|DepthToSpaceOptions|
        DepthwiseConv2DOptions|DequantizeOptions|DivOptions|EmbeddingLookupSparseOptions|
        EqualOptions|ExpOptions|ExpandDimsOptions|FakeQuantOptions|FillOptions|FloorDivOptions|
        FloorModOptions|FullyConnectedOptions|GatherNdOptions|GatherOptions|GreaterEqualOptions|
        GreaterOptions|HardSwishOptions|HashtableFindOptions|HashtableImportOptions|
        HashtableOptions|HashtableSizeOptions|IfOptions|InstanceNormOptions|L2NormOptions|
        LSHProjectionOptions|LSTMOptions|LeakyReluOptions|LessEqualOptions|LessOptions|
        LocalResponseNormalizationOptions|LogSoftmaxOptions|LogicalAndOptions|LogicalNotOptions|
        LogicalOrOptions|MatrixDiagOptions|MatrixSetDiagOptions|MaximumMinimumOptions|
        MirrorPadOptions|MulOptions|NegOptions|NonMaxSuppressionV4Options|
        NonMaxSuppressionV5Options|NotEqualOptions|OneHotOptions|PackOptions|PadOptions|
        PadV2Options|Pool2DOptions|PowOptions|QuantizeOptions|RNNOptions|RandomOptions|RangeOptions|
        RankOptions|ReadVariableOptions|ReducerOptions|ReshapeOptions|ResizeBilinearOptions|
        ResizeNearestNeighborOptions|ReverseSequenceOptions|ReverseV2Options|Rfft2dOptions|
        SVDFOptions|ScatterNdOptions|SegmentSumOptions|SelectOptions|SelectV2Options|
        SequenceRNNOptions|ShapeOptions|SkipGramOptions|SliceOptions|SoftmaxOptions|
        SpaceToBatchNDOptions|SpaceToDepthOptions|SparseToDenseOptions|SplitOptions|SplitVOptions|
        SquareOptions|SquaredDifferenceOptions|SqueezeOptions|StridedSliceOptions|SubOptions|
        TileOptions|TopKV2Options|TransposeConvOptions|TransposeOptions|
        UnidirectionalSequenceLSTMOptions|UniqueOptions|UnpackOptions|VarHandleOptions|WhereOptions|
        WhileOptions|ZerosLikeOptions) => AbsOptions | AddNOptions | AddOptions | ArgMaxOptions |
        ArgMinOptions | AssignVariableOptions | BCQFullyConnectedOptions | BCQGatherOptions |
        BatchMatMulOptions | BatchToSpaceNDOptions | BidirectionalSequenceLSTMOptions |
        BidirectionalSequenceRNNOptions | BroadcastToOptions | CallOnceOptions | CallOptions |
        CastOptions | ConcatEmbeddingsOptions | ConcatenationOptions | Conv2DOptions |
        Conv3DOptions | CosOptions | CumsumOptions | DensifyOptions | DepthToSpaceOptions |
        DepthwiseConv2DOptions | DequantizeOptions | DivOptions | EmbeddingLookupSparseOptions |
        EqualOptions | ExpOptions | ExpandDimsOptions | FakeQuantOptions | FillOptions |
        FloorDivOptions | FloorModOptions | FullyConnectedOptions | GatherNdOptions |
        GatherOptions | GreaterEqualOptions | GreaterOptions | HardSwishOptions |
        HashtableFindOptions | HashtableImportOptions | HashtableOptions | HashtableSizeOptions |
        IfOptions | InstanceNormOptions | L2NormOptions | LSHProjectionOptions | LSTMOptions |
        LeakyReluOptions | LessEqualOptions | LessOptions | LocalResponseNormalizationOptions |
        LogSoftmaxOptions | LogicalAndOptions | LogicalNotOptions | LogicalOrOptions |
        MatrixDiagOptions | MatrixSetDiagOptions | MaximumMinimumOptions | MirrorPadOptions |
        MulOptions | NegOptions | NonMaxSuppressionV4Options | NonMaxSuppressionV5Options |
        NotEqualOptions | OneHotOptions | PackOptions | PadOptions | PadV2Options | Pool2DOptions |
        PowOptions | QuantizeOptions | RNNOptions | RandomOptions | RangeOptions | RankOptions |
        ReadVariableOptions | ReducerOptions | ReshapeOptions | ResizeBilinearOptions |
        ResizeNearestNeighborOptions | ReverseSequenceOptions | ReverseV2Options | Rfft2dOptions |
        SVDFOptions | ScatterNdOptions | SegmentSumOptions | SelectOptions | SelectV2Options |
        SequenceRNNOptions | ShapeOptions | SkipGramOptions | SliceOptions | SoftmaxOptions |
        SpaceToBatchNDOptions | SpaceToDepthOptions | SparseToDenseOptions | SplitOptions |
        SplitVOptions | SquareOptions | SquaredDifferenceOptions | SqueezeOptions |
        StridedSliceOptions | SubOptions | TileOptions | TopKV2Options | TransposeConvOptions |
        TransposeOptions | UnidirectionalSequenceLSTMOptions | UniqueOptions | UnpackOptions |
        VarHandleOptions | WhereOptions | WhileOptions | ZerosLikeOptions | null,
    index: number): AbsOptions|AddNOptions|AddOptions|ArgMaxOptions|ArgMinOptions|
    AssignVariableOptions|BCQFullyConnectedOptions|BCQGatherOptions|BatchMatMulOptions|
    BatchToSpaceNDOptions|BidirectionalSequenceLSTMOptions|BidirectionalSequenceRNNOptions|
    BroadcastToOptions|CallOnceOptions|CallOptions|CastOptions|ConcatEmbeddingsOptions|
    ConcatenationOptions|Conv2DOptions|Conv3DOptions|CosOptions|CumsumOptions|DensifyOptions|
    DepthToSpaceOptions|DepthwiseConv2DOptions|DequantizeOptions|DivOptions|
    EmbeddingLookupSparseOptions|EqualOptions|ExpOptions|ExpandDimsOptions|FakeQuantOptions|
    FillOptions|FloorDivOptions|FloorModOptions|FullyConnectedOptions|GatherNdOptions|GatherOptions|
    GreaterEqualOptions|GreaterOptions|HardSwishOptions|HashtableFindOptions|HashtableImportOptions|
    HashtableOptions|HashtableSizeOptions|IfOptions|InstanceNormOptions|L2NormOptions|
    LSHProjectionOptions|LSTMOptions|LeakyReluOptions|LessEqualOptions|LessOptions|
    LocalResponseNormalizationOptions|LogSoftmaxOptions|LogicalAndOptions|LogicalNotOptions|
    LogicalOrOptions|MatrixDiagOptions|MatrixSetDiagOptions|MaximumMinimumOptions|MirrorPadOptions|
    MulOptions|NegOptions|NonMaxSuppressionV4Options|NonMaxSuppressionV5Options|NotEqualOptions|
    OneHotOptions|PackOptions|PadOptions|PadV2Options|Pool2DOptions|PowOptions|QuantizeOptions|
    RNNOptions|RandomOptions|RangeOptions|RankOptions|ReadVariableOptions|ReducerOptions|
    ReshapeOptions|ResizeBilinearOptions|ResizeNearestNeighborOptions|ReverseSequenceOptions|
    ReverseV2Options|Rfft2dOptions|SVDFOptions|ScatterNdOptions|SegmentSumOptions|SelectOptions|
    SelectV2Options|SequenceRNNOptions|ShapeOptions|SkipGramOptions|SliceOptions|SoftmaxOptions|
    SpaceToBatchNDOptions|SpaceToDepthOptions|SparseToDenseOptions|SplitOptions|SplitVOptions|
    SquareOptions|SquaredDifferenceOptions|SqueezeOptions|StridedSliceOptions|SubOptions|
    TileOptions|TopKV2Options|TransposeConvOptions|TransposeOptions|
    UnidirectionalSequenceLSTMOptions|UniqueOptions|UnpackOptions|VarHandleOptions|WhereOptions|
    WhileOptions|ZerosLikeOptions|null {
  switch (BuiltinOptions[type]) {
    case 'NONE':
      return null;
    case 'Conv2DOptions':
      return accessor(index, new Conv2DOptions())! as Conv2DOptions;
    case 'DepthwiseConv2DOptions':
      return accessor(index, new DepthwiseConv2DOptions())! as DepthwiseConv2DOptions;
    case 'ConcatEmbeddingsOptions':
      return accessor(index, new ConcatEmbeddingsOptions())! as ConcatEmbeddingsOptions;
    case 'LSHProjectionOptions':
      return accessor(index, new LSHProjectionOptions())! as LSHProjectionOptions;
    case 'Pool2DOptions':
      return accessor(index, new Pool2DOptions())! as Pool2DOptions;
    case 'SVDFOptions':
      return accessor(index, new SVDFOptions())! as SVDFOptions;
    case 'RNNOptions':
      return accessor(index, new RNNOptions())! as RNNOptions;
    case 'FullyConnectedOptions':
      return accessor(index, new FullyConnectedOptions())! as FullyConnectedOptions;
    case 'SoftmaxOptions':
      return accessor(index, new SoftmaxOptions())! as SoftmaxOptions;
    case 'ConcatenationOptions':
      return accessor(index, new ConcatenationOptions())! as ConcatenationOptions;
    case 'AddOptions':
      return accessor(index, new AddOptions())! as AddOptions;
    case 'L2NormOptions':
      return accessor(index, new L2NormOptions())! as L2NormOptions;
    case 'LocalResponseNormalizationOptions':
      return accessor(index, new LocalResponseNormalizationOptions())! as
          LocalResponseNormalizationOptions;
    case 'LSTMOptions':
      return accessor(index, new LSTMOptions())! as LSTMOptions;
    case 'ResizeBilinearOptions':
      return accessor(index, new ResizeBilinearOptions())! as ResizeBilinearOptions;
    case 'CallOptions':
      return accessor(index, new CallOptions())! as CallOptions;
    case 'ReshapeOptions':
      return accessor(index, new ReshapeOptions())! as ReshapeOptions;
    case 'SkipGramOptions':
      return accessor(index, new SkipGramOptions())! as SkipGramOptions;
    case 'SpaceToDepthOptions':
      return accessor(index, new SpaceToDepthOptions())! as SpaceToDepthOptions;
    case 'EmbeddingLookupSparseOptions':
      return accessor(index, new EmbeddingLookupSparseOptions())! as EmbeddingLookupSparseOptions;
    case 'MulOptions':
      return accessor(index, new MulOptions())! as MulOptions;
    case 'PadOptions':
      return accessor(index, new PadOptions())! as PadOptions;
    case 'GatherOptions':
      return accessor(index, new GatherOptions())! as GatherOptions;
    case 'BatchToSpaceNDOptions':
      return accessor(index, new BatchToSpaceNDOptions())! as BatchToSpaceNDOptions;
    case 'SpaceToBatchNDOptions':
      return accessor(index, new SpaceToBatchNDOptions())! as SpaceToBatchNDOptions;
    case 'TransposeOptions':
      return accessor(index, new TransposeOptions())! as TransposeOptions;
    case 'ReducerOptions':
      return accessor(index, new ReducerOptions())! as ReducerOptions;
    case 'SubOptions':
      return accessor(index, new SubOptions())! as SubOptions;
    case 'DivOptions':
      return accessor(index, new DivOptions())! as DivOptions;
    case 'SqueezeOptions':
      return accessor(index, new SqueezeOptions())! as SqueezeOptions;
    case 'SequenceRNNOptions':
      return accessor(index, new SequenceRNNOptions())! as SequenceRNNOptions;
    case 'StridedSliceOptions':
      return accessor(index, new StridedSliceOptions())! as StridedSliceOptions;
    case 'ExpOptions':
      return accessor(index, new ExpOptions())! as ExpOptions;
    case 'TopKV2Options':
      return accessor(index, new TopKV2Options())! as TopKV2Options;
    case 'SplitOptions':
      return accessor(index, new SplitOptions())! as SplitOptions;
    case 'LogSoftmaxOptions':
      return accessor(index, new LogSoftmaxOptions())! as LogSoftmaxOptions;
    case 'CastOptions':
      return accessor(index, new CastOptions())! as CastOptions;
    case 'DequantizeOptions':
      return accessor(index, new DequantizeOptions())! as DequantizeOptions;
    case 'MaximumMinimumOptions':
      return accessor(index, new MaximumMinimumOptions())! as MaximumMinimumOptions;
    case 'ArgMaxOptions':
      return accessor(index, new ArgMaxOptions())! as ArgMaxOptions;
    case 'LessOptions':
      return accessor(index, new LessOptions())! as LessOptions;
    case 'NegOptions':
      return accessor(index, new NegOptions())! as NegOptions;
    case 'PadV2Options':
      return accessor(index, new PadV2Options())! as PadV2Options;
    case 'GreaterOptions':
      return accessor(index, new GreaterOptions())! as GreaterOptions;
    case 'GreaterEqualOptions':
      return accessor(index, new GreaterEqualOptions())! as GreaterEqualOptions;
    case 'LessEqualOptions':
      return accessor(index, new LessEqualOptions())! as LessEqualOptions;
    case 'SelectOptions':
      return accessor(index, new SelectOptions())! as SelectOptions;
    case 'SliceOptions':
      return accessor(index, new SliceOptions())! as SliceOptions;
    case 'TransposeConvOptions':
      return accessor(index, new TransposeConvOptions())! as TransposeConvOptions;
    case 'SparseToDenseOptions':
      return accessor(index, new SparseToDenseOptions())! as SparseToDenseOptions;
    case 'TileOptions':
      return accessor(index, new TileOptions())! as TileOptions;
    case 'ExpandDimsOptions':
      return accessor(index, new ExpandDimsOptions())! as ExpandDimsOptions;
    case 'EqualOptions':
      return accessor(index, new EqualOptions())! as EqualOptions;
    case 'NotEqualOptions':
      return accessor(index, new NotEqualOptions())! as NotEqualOptions;
    case 'ShapeOptions':
      return accessor(index, new ShapeOptions())! as ShapeOptions;
    case 'PowOptions':
      return accessor(index, new PowOptions())! as PowOptions;
    case 'ArgMinOptions':
      return accessor(index, new ArgMinOptions())! as ArgMinOptions;
    case 'FakeQuantOptions':
      return accessor(index, new FakeQuantOptions())! as FakeQuantOptions;
    case 'PackOptions':
      return accessor(index, new PackOptions())! as PackOptions;
    case 'LogicalOrOptions':
      return accessor(index, new LogicalOrOptions())! as LogicalOrOptions;
    case 'OneHotOptions':
      return accessor(index, new OneHotOptions())! as OneHotOptions;
    case 'LogicalAndOptions':
      return accessor(index, new LogicalAndOptions())! as LogicalAndOptions;
    case 'LogicalNotOptions':
      return accessor(index, new LogicalNotOptions())! as LogicalNotOptions;
    case 'UnpackOptions':
      return accessor(index, new UnpackOptions())! as UnpackOptions;
    case 'FloorDivOptions':
      return accessor(index, new FloorDivOptions())! as FloorDivOptions;
    case 'SquareOptions':
      return accessor(index, new SquareOptions())! as SquareOptions;
    case 'ZerosLikeOptions':
      return accessor(index, new ZerosLikeOptions())! as ZerosLikeOptions;
    case 'FillOptions':
      return accessor(index, new FillOptions())! as FillOptions;
    case 'BidirectionalSequenceLSTMOptions':
      return accessor(index, new BidirectionalSequenceLSTMOptions())! as
          BidirectionalSequenceLSTMOptions;
    case 'BidirectionalSequenceRNNOptions':
      return accessor(index, new BidirectionalSequenceRNNOptions())! as
          BidirectionalSequenceRNNOptions;
    case 'UnidirectionalSequenceLSTMOptions':
      return accessor(index, new UnidirectionalSequenceLSTMOptions())! as
          UnidirectionalSequenceLSTMOptions;
    case 'FloorModOptions':
      return accessor(index, new FloorModOptions())! as FloorModOptions;
    case 'RangeOptions':
      return accessor(index, new RangeOptions())! as RangeOptions;
    case 'ResizeNearestNeighborOptions':
      return accessor(index, new ResizeNearestNeighborOptions())! as ResizeNearestNeighborOptions;
    case 'LeakyReluOptions':
      return accessor(index, new LeakyReluOptions())! as LeakyReluOptions;
    case 'SquaredDifferenceOptions':
      return accessor(index, new SquaredDifferenceOptions())! as SquaredDifferenceOptions;
    case 'MirrorPadOptions':
      return accessor(index, new MirrorPadOptions())! as MirrorPadOptions;
    case 'AbsOptions':
      return accessor(index, new AbsOptions())! as AbsOptions;
    case 'SplitVOptions':
      return accessor(index, new SplitVOptions())! as SplitVOptions;
    case 'UniqueOptions':
      return accessor(index, new UniqueOptions())! as UniqueOptions;
    case 'ReverseV2Options':
      return accessor(index, new ReverseV2Options())! as ReverseV2Options;
    case 'AddNOptions':
      return accessor(index, new AddNOptions())! as AddNOptions;
    case 'GatherNdOptions':
      return accessor(index, new GatherNdOptions())! as GatherNdOptions;
    case 'CosOptions':
      return accessor(index, new CosOptions())! as CosOptions;
    case 'WhereOptions':
      return accessor(index, new WhereOptions())! as WhereOptions;
    case 'RankOptions':
      return accessor(index, new RankOptions())! as RankOptions;
    case 'ReverseSequenceOptions':
      return accessor(index, new ReverseSequenceOptions())! as ReverseSequenceOptions;
    case 'MatrixDiagOptions':
      return accessor(index, new MatrixDiagOptions())! as MatrixDiagOptions;
    case 'QuantizeOptions':
      return accessor(index, new QuantizeOptions())! as QuantizeOptions;
    case 'MatrixSetDiagOptions':
      return accessor(index, new MatrixSetDiagOptions())! as MatrixSetDiagOptions;
    case 'HardSwishOptions':
      return accessor(index, new HardSwishOptions())! as HardSwishOptions;
    case 'IfOptions':
      return accessor(index, new IfOptions())! as IfOptions;
    case 'WhileOptions':
      return accessor(index, new WhileOptions())! as WhileOptions;
    case 'DepthToSpaceOptions':
      return accessor(index, new DepthToSpaceOptions())! as DepthToSpaceOptions;
    case 'NonMaxSuppressionV4Options':
      return accessor(index, new NonMaxSuppressionV4Options())! as NonMaxSuppressionV4Options;
    case 'NonMaxSuppressionV5Options':
      return accessor(index, new NonMaxSuppressionV5Options())! as NonMaxSuppressionV5Options;
    case 'ScatterNdOptions':
      return accessor(index, new ScatterNdOptions())! as ScatterNdOptions;
    case 'SelectV2Options':
      return accessor(index, new SelectV2Options())! as SelectV2Options;
    case 'DensifyOptions':
      return accessor(index, new DensifyOptions())! as DensifyOptions;
    case 'SegmentSumOptions':
      return accessor(index, new SegmentSumOptions())! as SegmentSumOptions;
    case 'BatchMatMulOptions':
      return accessor(index, new BatchMatMulOptions())! as BatchMatMulOptions;
    case 'CumsumOptions':
      return accessor(index, new CumsumOptions())! as CumsumOptions;
    case 'CallOnceOptions':
      return accessor(index, new CallOnceOptions())! as CallOnceOptions;
    case 'BroadcastToOptions':
      return accessor(index, new BroadcastToOptions())! as BroadcastToOptions;
    case 'Rfft2dOptions':
      return accessor(index, new Rfft2dOptions())! as Rfft2dOptions;
    case 'Conv3DOptions':
      return accessor(index, new Conv3DOptions())! as Conv3DOptions;
    case 'HashtableOptions':
      return accessor(index, new HashtableOptions())! as HashtableOptions;
    case 'HashtableFindOptions':
      return accessor(index, new HashtableFindOptions())! as HashtableFindOptions;
    case 'HashtableImportOptions':
      return accessor(index, new HashtableImportOptions())! as HashtableImportOptions;
    case 'HashtableSizeOptions':
      return accessor(index, new HashtableSizeOptions())! as HashtableSizeOptions;
    case 'VarHandleOptions':
      return accessor(index, new VarHandleOptions())! as VarHandleOptions;
    case 'ReadVariableOptions':
      return accessor(index, new ReadVariableOptions())! as ReadVariableOptions;
    case 'AssignVariableOptions':
      return accessor(index, new AssignVariableOptions())! as AssignVariableOptions;
    case 'RandomOptions':
      return accessor(index, new RandomOptions())! as RandomOptions;
    case 'BCQGatherOptions':
      return accessor(index, new BCQGatherOptions())! as BCQGatherOptions;
    case 'BCQFullyConnectedOptions':
      return accessor(index, new BCQFullyConnectedOptions())! as BCQFullyConnectedOptions;
    case 'InstanceNormOptions':
      return accessor(index, new InstanceNormOptions())! as InstanceNormOptions;
    default:
      return null;
  }
}

export enum Padding {
  SAME = 0,
  VALID = 1
}

export enum ActivationFunctionType {
  NONE = 0,
  RELU = 1,
  RELU_N1_TO_1 = 2,
  RELU6 = 3,
  TANH = 4,
  SIGN_BIT = 5
}

export enum LSHProjectionType {
  UNKNOWN = 0,
  SPARSE = 1,
  DENSE = 2
}

export enum FullyConnectedOptionsWeightsFormat {
  DEFAULT = 0,
  SHUFFLED4x16INT8 = 1,
  SHUFFLED16x1FLOAT32 = 127
}

export enum LSTMKernelType {
  FULL = 0,
  BASIC = 1
}

export enum CombinerType {
  SUM = 0,
  MEAN = 1,
  SQRTN = 2
}

export enum MirrorPadMode {
  REFLECT = 0,
  SYMMETRIC = 1
}

export enum CustomOptionsFormat {
  FLEXBUFFERS = 0
}

export enum DataFormat {
  CHANNELS_LAST = 0,
  CHANNELS_FIRST = 1
}

export class CustomQuantization {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CustomQuantization {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCustomQuantization(bb: flatbuffers.ByteBuffer, obj?: CustomQuantization):
      CustomQuantization {
    return (obj || new CustomQuantization())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCustomQuantization(
      bb: flatbuffers.ByteBuffer, obj?: CustomQuantization): CustomQuantization {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CustomQuantization())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  custom(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
  }

  customLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  customArray(): Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Uint8Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startCustomQuantization(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addCustom(builder: flatbuffers.Builder, customOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, customOffset, 0);
  }

  static createCustomVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(1, data.length, 1);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!);
    }
    return builder.endVector();
  }

  static startCustomVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1);
  }

  static endCustomQuantization(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCustomQuantization(builder: flatbuffers.Builder, customOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    CustomQuantization.startCustomQuantization(builder);
    CustomQuantization.addCustom(builder, customOffset);
    return CustomQuantization.endCustomQuantization(builder);
  }

  unpack(): CustomQuantizationT {
    return new CustomQuantizationT(
        this.bb!.createScalarList(this.custom.bind(this), this.customLength()));
  }


  unpackTo(_o: CustomQuantizationT): void {
    _o.custom = this.bb!.createScalarList(this.custom.bind(this), this.customLength());
  }
}

export class CustomQuantizationT {
  constructor(public custom: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const custom = CustomQuantization.createCustomVector(builder, this.custom);

    return CustomQuantization.createCustomQuantization(builder, custom);
  }
}

export class QuantizationParameters {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): QuantizationParameters {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsQuantizationParameters(bb: flatbuffers.ByteBuffer, obj?: QuantizationParameters):
      QuantizationParameters {
    return (obj || new QuantizationParameters())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsQuantizationParameters(
      bb: flatbuffers.ByteBuffer, obj?: QuantizationParameters): QuantizationParameters {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new QuantizationParameters())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  min(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  minLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  minArray(): Float32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Float32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  max(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  maxLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  maxArray(): Float32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? new Float32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  scale(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readFloat32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  scaleLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  scaleArray(): Float32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? new Float32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  zeroPoint(index: number): bigint|null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt64(this.bb!.__vector(this.bb_pos + offset) + index * 8) :
                    BigInt(0);
  }

  zeroPointLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  detailsType(): QuantizationDetails {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : QuantizationDetails.NONE;
  }

  details<T extends flatbuffers.Table>(obj: any): any|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  quantizedDimension(): number {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startQuantizationParameters(builder: flatbuffers.Builder) {
    builder.startObject(7);
  }

  static addMin(builder: flatbuffers.Builder, minOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, minOffset, 0);
  }

  static createMinVector(builder: flatbuffers.Builder, data: number[]|Float32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createMinVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createMinVector(builder: flatbuffers.Builder, data: number[]|Float32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]!);
    }
    return builder.endVector();
  }

  static startMinVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addMax(builder: flatbuffers.Builder, maxOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, maxOffset, 0);
  }

  static createMaxVector(builder: flatbuffers.Builder, data: number[]|Float32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createMaxVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createMaxVector(builder: flatbuffers.Builder, data: number[]|Float32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]!);
    }
    return builder.endVector();
  }

  static startMaxVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addScale(builder: flatbuffers.Builder, scaleOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, scaleOffset, 0);
  }

  static createScaleVector(builder: flatbuffers.Builder, data: number[]|Float32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createScaleVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createScaleVector(builder: flatbuffers.Builder, data: number[]|Float32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addFloat32(data[i]!);
    }
    return builder.endVector();
  }

  static startScaleVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addZeroPoint(builder: flatbuffers.Builder, zeroPointOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, zeroPointOffset, 0);
  }

  static createZeroPointVector(builder: flatbuffers.Builder, data: bigint[]): flatbuffers.Offset {
    builder.startVector(8, data.length, 8);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt64(data[i]!);
    }
    return builder.endVector();
  }

  static startZeroPointVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(8, numElems, 8);
  }

  static addDetailsType(builder: flatbuffers.Builder, detailsType: QuantizationDetails) {
    builder.addFieldInt8(4, detailsType, QuantizationDetails.NONE);
  }

  static addDetails(builder: flatbuffers.Builder, detailsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(5, detailsOffset, 0);
  }

  static addQuantizedDimension(builder: flatbuffers.Builder, quantizedDimension: number) {
    builder.addFieldInt32(6, quantizedDimension, 0);
  }

  static endQuantizationParameters(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createQuantizationParameters(
      builder: flatbuffers.Builder, minOffset: flatbuffers.Offset, maxOffset: flatbuffers.Offset,
      scaleOffset: flatbuffers.Offset, zeroPointOffset: flatbuffers.Offset,
      detailsType: QuantizationDetails, detailsOffset: flatbuffers.Offset,
      quantizedDimension: number): flatbuffers.Offset {
    QuantizationParameters.startQuantizationParameters(builder);
    QuantizationParameters.addMin(builder, minOffset);
    QuantizationParameters.addMax(builder, maxOffset);
    QuantizationParameters.addScale(builder, scaleOffset);
    QuantizationParameters.addZeroPoint(builder, zeroPointOffset);
    QuantizationParameters.addDetailsType(builder, detailsType);
    QuantizationParameters.addDetails(builder, detailsOffset);
    QuantizationParameters.addQuantizedDimension(builder, quantizedDimension);
    return QuantizationParameters.endQuantizationParameters(builder);
  }

  unpack(): QuantizationParametersT {
    return new QuantizationParametersT(
        this.bb!.createScalarList(this.min.bind(this), this.minLength()),
        this.bb!.createScalarList(this.max.bind(this), this.maxLength()),
        this.bb!.createScalarList(this.scale.bind(this), this.scaleLength()),
        this.bb!.createScalarList(this.zeroPoint.bind(this), this.zeroPointLength()),
        this.detailsType(), (() => {
          let temp = unionToQuantizationDetails(this.detailsType(), this.details.bind(this));
          if (temp === null) {
            return null;
          }
          return temp.unpack()
        })(),
        this.quantizedDimension());
  }


  unpackTo(_o: QuantizationParametersT): void {
    _o.min = this.bb!.createScalarList(this.min.bind(this), this.minLength());
    _o.max = this.bb!.createScalarList(this.max.bind(this), this.maxLength());
    _o.scale = this.bb!.createScalarList(this.scale.bind(this), this.scaleLength());
    _o.zeroPoint = this.bb!.createScalarList(this.zeroPoint.bind(this), this.zeroPointLength());
    _o.detailsType = this.detailsType();
    _o.details = (() => {
      let temp = unionToQuantizationDetails(this.detailsType(), this.details.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack()
    })();
    _o.quantizedDimension = this.quantizedDimension();
  }
}

export class QuantizationParametersT {
  constructor(
      public min: (number)[] = [], public max: (number)[] = [], public scale: (number)[] = [],
      public zeroPoint: (bigint)[] = [],
      public detailsType: QuantizationDetails = QuantizationDetails.NONE,
      public details: CustomQuantizationT|null = null, public quantizedDimension: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const min = QuantizationParameters.createMinVector(builder, this.min);
    const max = QuantizationParameters.createMaxVector(builder, this.max);
    const scale = QuantizationParameters.createScaleVector(builder, this.scale);
    const zeroPoint = QuantizationParameters.createZeroPointVector(builder, this.zeroPoint);
    const details = builder.createObjectOffset(this.details);

    return QuantizationParameters.createQuantizationParameters(
        builder, min, max, scale, zeroPoint, this.detailsType, details, this.quantizedDimension);
  }
}

export class Int32Vector {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Int32Vector {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsInt32Vector(bb: flatbuffers.ByteBuffer, obj?: Int32Vector): Int32Vector {
    return (obj || new Int32Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsInt32Vector(bb: flatbuffers.ByteBuffer, obj?: Int32Vector):
      Int32Vector {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Int32Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  values(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  valuesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  valuesArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startInt32Vector(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, valuesOffset, 0);
  }

  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startValuesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endInt32Vector(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createInt32Vector(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    Int32Vector.startInt32Vector(builder);
    Int32Vector.addValues(builder, valuesOffset);
    return Int32Vector.endInt32Vector(builder);
  }

  unpack(): Int32VectorT {
    return new Int32VectorT(this.bb!.createScalarList(this.values.bind(this), this.valuesLength()));
  }


  unpackTo(_o: Int32VectorT): void {
    _o.values = this.bb!.createScalarList(this.values.bind(this), this.valuesLength());
  }
}

export class Int32VectorT {
  constructor(public values: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const values = Int32Vector.createValuesVector(builder, this.values);

    return Int32Vector.createInt32Vector(builder, values);
  }
}

export class Uint16Vector {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Uint16Vector {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsUint16Vector(bb: flatbuffers.ByteBuffer, obj?: Uint16Vector): Uint16Vector {
    return (obj || new Uint16Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsUint16Vector(bb: flatbuffers.ByteBuffer, obj?: Uint16Vector):
      Uint16Vector {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Uint16Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  values(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint16(this.bb!.__vector(this.bb_pos + offset) + index * 2) : 0;
  }

  valuesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  valuesArray(): Uint16Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Uint16Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startUint16Vector(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, valuesOffset, 0);
  }

  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Uint16Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Uint16Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(2, data.length, 2);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt16(data[i]!);
    }
    return builder.endVector();
  }

  static startValuesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(2, numElems, 2);
  }

  static endUint16Vector(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createUint16Vector(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    Uint16Vector.startUint16Vector(builder);
    Uint16Vector.addValues(builder, valuesOffset);
    return Uint16Vector.endUint16Vector(builder);
  }

  unpack(): Uint16VectorT {
    return new Uint16VectorT(
        this.bb!.createScalarList(this.values.bind(this), this.valuesLength()));
  }


  unpackTo(_o: Uint16VectorT): void {
    _o.values = this.bb!.createScalarList(this.values.bind(this), this.valuesLength());
  }
}

export class Uint16VectorT {
  constructor(public values: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const values = Uint16Vector.createValuesVector(builder, this.values);

    return Uint16Vector.createUint16Vector(builder, values);
  }
}

export class Uint8Vector {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Uint8Vector {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsUint8Vector(bb: flatbuffers.ByteBuffer, obj?: Uint8Vector): Uint8Vector {
    return (obj || new Uint8Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsUint8Vector(bb: flatbuffers.ByteBuffer, obj?: Uint8Vector):
      Uint8Vector {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Uint8Vector()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  values(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
  }

  valuesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  valuesArray(): Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Uint8Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startUint8Vector(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addValues(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, valuesOffset, 0);
  }

  static createValuesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(1, data.length, 1);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!);
    }
    return builder.endVector();
  }

  static startValuesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1);
  }

  static endUint8Vector(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createUint8Vector(builder: flatbuffers.Builder, valuesOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    Uint8Vector.startUint8Vector(builder);
    Uint8Vector.addValues(builder, valuesOffset);
    return Uint8Vector.endUint8Vector(builder);
  }

  unpack(): Uint8VectorT {
    return new Uint8VectorT(this.bb!.createScalarList(this.values.bind(this), this.valuesLength()));
  }


  unpackTo(_o: Uint8VectorT): void {
    _o.values = this.bb!.createScalarList(this.values.bind(this), this.valuesLength());
  }
}

export class Uint8VectorT {
  constructor(public values: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const values = Uint8Vector.createValuesVector(builder, this.values);

    return Uint8Vector.createUint8Vector(builder, values);
  }
}

export class DimensionMetadata {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DimensionMetadata {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDimensionMetadata(bb: flatbuffers.ByteBuffer, obj?: DimensionMetadata):
      DimensionMetadata {
    return (obj || new DimensionMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDimensionMetadata(
      bb: flatbuffers.ByteBuffer, obj?: DimensionMetadata): DimensionMetadata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DimensionMetadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  format(): DimensionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : DimensionType.DENSE;
  }

  denseSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  arraySegmentsType(): SparseIndexVector {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : SparseIndexVector.NONE;
  }

  arraySegments<T extends flatbuffers.Table>(obj: any): any|null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  arrayIndicesType(): SparseIndexVector {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : SparseIndexVector.NONE;
  }

  arrayIndices<T extends flatbuffers.Table>(obj: any): any|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  static startDimensionMetadata(builder: flatbuffers.Builder) {
    builder.startObject(6);
  }

  static addFormat(builder: flatbuffers.Builder, format: DimensionType) {
    builder.addFieldInt8(0, format, DimensionType.DENSE);
  }

  static addDenseSize(builder: flatbuffers.Builder, denseSize: number) {
    builder.addFieldInt32(1, denseSize, 0);
  }

  static addArraySegmentsType(builder: flatbuffers.Builder, arraySegmentsType: SparseIndexVector) {
    builder.addFieldInt8(2, arraySegmentsType, SparseIndexVector.NONE);
  }

  static addArraySegments(builder: flatbuffers.Builder, arraySegmentsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, arraySegmentsOffset, 0);
  }

  static addArrayIndicesType(builder: flatbuffers.Builder, arrayIndicesType: SparseIndexVector) {
    builder.addFieldInt8(4, arrayIndicesType, SparseIndexVector.NONE);
  }

  static addArrayIndices(builder: flatbuffers.Builder, arrayIndicesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(5, arrayIndicesOffset, 0);
  }

  static endDimensionMetadata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDimensionMetadata(
      builder: flatbuffers.Builder, format: DimensionType, denseSize: number,
      arraySegmentsType: SparseIndexVector, arraySegmentsOffset: flatbuffers.Offset,
      arrayIndicesType: SparseIndexVector,
      arrayIndicesOffset: flatbuffers.Offset): flatbuffers.Offset {
    DimensionMetadata.startDimensionMetadata(builder);
    DimensionMetadata.addFormat(builder, format);
    DimensionMetadata.addDenseSize(builder, denseSize);
    DimensionMetadata.addArraySegmentsType(builder, arraySegmentsType);
    DimensionMetadata.addArraySegments(builder, arraySegmentsOffset);
    DimensionMetadata.addArrayIndicesType(builder, arrayIndicesType);
    DimensionMetadata.addArrayIndices(builder, arrayIndicesOffset);
    return DimensionMetadata.endDimensionMetadata(builder);
  }

  unpack(): DimensionMetadataT {
    return new DimensionMetadataT(
        this.format(), this.denseSize(), this.arraySegmentsType(), (() => {
          let temp =
              unionToSparseIndexVector(this.arraySegmentsType(), this.arraySegments.bind(this));
          if (temp === null) {
            return null;
          }
          return temp.unpack()
        })(),
        this.arrayIndicesType(), (() => {
          let temp =
              unionToSparseIndexVector(this.arrayIndicesType(), this.arrayIndices.bind(this));
          if (temp === null) {
            return null;
          }
          return temp.unpack()
        })());
  }


  unpackTo(_o: DimensionMetadataT): void {
    _o.format = this.format();
    _o.denseSize = this.denseSize();
    _o.arraySegmentsType = this.arraySegmentsType();
    _o.arraySegments = (() => {
      let temp = unionToSparseIndexVector(this.arraySegmentsType(), this.arraySegments.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack()
    })();
    _o.arrayIndicesType = this.arrayIndicesType();
    _o.arrayIndices = (() => {
      let temp = unionToSparseIndexVector(this.arrayIndicesType(), this.arrayIndices.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack()
    })();
  }
}

export class DimensionMetadataT {
  constructor(
      public format: DimensionType = DimensionType.DENSE, public denseSize: number = 0,
      public arraySegmentsType: SparseIndexVector = SparseIndexVector.NONE,
      public arraySegments: Int32VectorT|Uint16VectorT|Uint8VectorT|null = null,
      public arrayIndicesType: SparseIndexVector = SparseIndexVector.NONE,
      public arrayIndices: Int32VectorT|Uint16VectorT|Uint8VectorT|null = null) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const arraySegments = builder.createObjectOffset(this.arraySegments);
    const arrayIndices = builder.createObjectOffset(this.arrayIndices);

    return DimensionMetadata.createDimensionMetadata(
        builder, this.format, this.denseSize, this.arraySegmentsType, arraySegments,
        this.arrayIndicesType, arrayIndices);
  }
}

export class SparsityParameters {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SparsityParameters {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSparsityParameters(bb: flatbuffers.ByteBuffer, obj?: SparsityParameters):
      SparsityParameters {
    return (obj || new SparsityParameters())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSparsityParameters(
      bb: flatbuffers.ByteBuffer, obj?: SparsityParameters): SparsityParameters {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SparsityParameters())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  traversalOrder(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  traversalOrderLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  traversalOrderArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  blockMap(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  blockMapLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  blockMapArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  dimMetadata(index: number, obj?: DimensionMetadata): DimensionMetadata|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ?
        (obj || new DimensionMetadata())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  dimMetadataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  static startSparsityParameters(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addTraversalOrder(builder: flatbuffers.Builder, traversalOrderOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, traversalOrderOffset, 0);
  }

  static createTraversalOrderVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createTraversalOrderVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createTraversalOrderVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startTraversalOrderVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addBlockMap(builder: flatbuffers.Builder, blockMapOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, blockMapOffset, 0);
  }

  static createBlockMapVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createBlockMapVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createBlockMapVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startBlockMapVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addDimMetadata(builder: flatbuffers.Builder, dimMetadataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, dimMetadataOffset, 0);
  }

  static createDimMetadataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startDimMetadataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endSparsityParameters(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSparsityParameters(
      builder: flatbuffers.Builder, traversalOrderOffset: flatbuffers.Offset,
      blockMapOffset: flatbuffers.Offset,
      dimMetadataOffset: flatbuffers.Offset): flatbuffers.Offset {
    SparsityParameters.startSparsityParameters(builder);
    SparsityParameters.addTraversalOrder(builder, traversalOrderOffset);
    SparsityParameters.addBlockMap(builder, blockMapOffset);
    SparsityParameters.addDimMetadata(builder, dimMetadataOffset);
    return SparsityParameters.endSparsityParameters(builder);
  }

  unpack(): SparsityParametersT {
    return new SparsityParametersT(
        this.bb!.createScalarList(this.traversalOrder.bind(this), this.traversalOrderLength()),
        this.bb!.createScalarList(this.blockMap.bind(this), this.blockMapLength()),
        this.bb!.createObjList(this.dimMetadata.bind(this), this.dimMetadataLength()));
  }


  unpackTo(_o: SparsityParametersT): void {
    _o.traversalOrder =
        this.bb!.createScalarList(this.traversalOrder.bind(this), this.traversalOrderLength());
    _o.blockMap = this.bb!.createScalarList(this.blockMap.bind(this), this.blockMapLength());
    _o.dimMetadata = this.bb!.createObjList(this.dimMetadata.bind(this), this.dimMetadataLength());
  }
}

export class SparsityParametersT {
  constructor(
      public traversalOrder: (number)[] = [], public blockMap: (number)[] = [],
      public dimMetadata: (DimensionMetadataT)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const traversalOrder =
        SparsityParameters.createTraversalOrderVector(builder, this.traversalOrder);
    const blockMap = SparsityParameters.createBlockMapVector(builder, this.blockMap);
    const dimMetadata = SparsityParameters.createDimMetadataVector(
        builder, builder.createObjectOffsetList(this.dimMetadata));

    return SparsityParameters.createSparsityParameters(
        builder, traversalOrder, blockMap, dimMetadata);
  }
}

export class Tensor {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Tensor {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {
    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTensor(bb: flatbuffers.ByteBuffer, obj?: Tensor): Tensor {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Tensor()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  shape(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  shapeLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  shapeArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  type(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  buffer(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  name(): string|null
  name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  name(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  quantization(obj?: QuantizationParameters): QuantizationParameters|null {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? (obj || new QuantizationParameters())
                        .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :
                    null;
  }

  isVariable(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  sparsity(obj?: SparsityParameters): SparsityParameters|null {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? (obj || new SparsityParameters())
                        .__init(this.bb!.__indirect(this.bb_pos + offset), this.bb!) :
                    null;
  }

  shapeSignature(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  shapeSignatureLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  shapeSignatureArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startTensor(builder: flatbuffers.Builder) {
    builder.startObject(8);
  }

  static addShape(builder: flatbuffers.Builder, shapeOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, shapeOffset, 0);
  }

  static createShapeVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createShapeVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createShapeVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startShapeVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addType(builder: flatbuffers.Builder, type: TensorType) {
    builder.addFieldInt8(1, type, TensorType.FLOAT32);
  }

  static addBuffer(builder: flatbuffers.Builder, buffer: number) {
    builder.addFieldInt32(2, buffer, 0);
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, nameOffset, 0);
  }

  static addQuantization(builder: flatbuffers.Builder, quantizationOffset: flatbuffers.Offset) {
    builder.addFieldOffset(4, quantizationOffset, 0);
  }

  static addIsVariable(builder: flatbuffers.Builder, isVariable: boolean) {
    builder.addFieldInt8(5, +isVariable, +false);
  }

  static addSparsity(builder: flatbuffers.Builder, sparsityOffset: flatbuffers.Offset) {
    builder.addFieldOffset(6, sparsityOffset, 0);
  }

  static addShapeSignature(builder: flatbuffers.Builder, shapeSignatureOffset: flatbuffers.Offset) {
    builder.addFieldOffset(7, shapeSignatureOffset, 0);
  }

  static createShapeSignatureVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createShapeSignatureVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createShapeSignatureVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startShapeSignatureVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endTensor(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }


  unpack(): TensorT {
    return new TensorT(
        this.bb!.createScalarList(this.shape.bind(this), this.shapeLength()), this.type(),
        this.buffer(), this.name(),
        (this.quantization() !== null ? this.quantization()!.unpack() : null), this.isVariable(),
        (this.sparsity() !== null ? this.sparsity()!.unpack() : null),
        this.bb!.createScalarList(this.shapeSignature.bind(this), this.shapeSignatureLength()));
  }


  unpackTo(_o: TensorT): void {
    _o.shape = this.bb!.createScalarList(this.shape.bind(this), this.shapeLength());
    _o.type = this.type();
    _o.buffer = this.buffer();
    _o.name = this.name();
    _o.quantization = (this.quantization() !== null ? this.quantization()!.unpack() : null);
    _o.isVariable = this.isVariable();
    _o.sparsity = (this.sparsity() !== null ? this.sparsity()!.unpack() : null);
    _o.shapeSignature =
        this.bb!.createScalarList(this.shapeSignature.bind(this), this.shapeSignatureLength());
  }
}

export class TensorT {
  constructor(
      public shape: (number)[] = [], public type: TensorType = TensorType.FLOAT32,
      public buffer: number = 0, public name: string|Uint8Array|null = null,
      public quantization: QuantizationParametersT|null = null, public isVariable: boolean = false,
      public sparsity: SparsityParametersT|null = null, public shapeSignature: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const shape = Tensor.createShapeVector(builder, this.shape);
    const name = (this.name !== null ? builder.createString(this.name!) : 0);
    const quantization = (this.quantization !== null ? this.quantization!.pack(builder) : 0);
    const sparsity = (this.sparsity !== null ? this.sparsity!.pack(builder) : 0);
    const shapeSignature = Tensor.createShapeSignatureVector(builder, this.shapeSignature);

    Tensor.startTensor(builder);
    Tensor.addShape(builder, shape);
    Tensor.addType(builder, this.type);
    Tensor.addBuffer(builder, this.buffer);
    Tensor.addName(builder, name);
    Tensor.addQuantization(builder, quantization);
    Tensor.addIsVariable(builder, this.isVariable);
    Tensor.addSparsity(builder, sparsity);
    Tensor.addShapeSignature(builder, shapeSignature);

    return Tensor.endTensor(builder);
  }
}

export class Conv2DOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Conv2DOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsConv2DOptions(bb: flatbuffers.ByteBuffer, obj?: Conv2DOptions): Conv2DOptions {
    return (obj || new Conv2DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsConv2DOptions(bb: flatbuffers.ByteBuffer, obj?: Conv2DOptions):
      Conv2DOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Conv2DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  padding(): Padding {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : Padding.SAME;
  }

  strideW(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideH(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  dilationWFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  dilationHFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  static startConv2DOptions(builder: flatbuffers.Builder) {
    builder.startObject(6);
  }

  static addPadding(builder: flatbuffers.Builder, padding: Padding) {
    builder.addFieldInt8(0, padding, Padding.SAME);
  }

  static addStrideW(builder: flatbuffers.Builder, strideW: number) {
    builder.addFieldInt32(1, strideW, 0);
  }

  static addStrideH(builder: flatbuffers.Builder, strideH: number) {
    builder.addFieldInt32(2, strideH, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(3, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addDilationWFactor(builder: flatbuffers.Builder, dilationWFactor: number) {
    builder.addFieldInt32(4, dilationWFactor, 1);
  }

  static addDilationHFactor(builder: flatbuffers.Builder, dilationHFactor: number) {
    builder.addFieldInt32(5, dilationHFactor, 1);
  }

  static endConv2DOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createConv2DOptions(
      builder: flatbuffers.Builder, padding: Padding, strideW: number, strideH: number,
      fusedActivationFunction: ActivationFunctionType, dilationWFactor: number,
      dilationHFactor: number): flatbuffers.Offset {
    Conv2DOptions.startConv2DOptions(builder);
    Conv2DOptions.addPadding(builder, padding);
    Conv2DOptions.addStrideW(builder, strideW);
    Conv2DOptions.addStrideH(builder, strideH);
    Conv2DOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    Conv2DOptions.addDilationWFactor(builder, dilationWFactor);
    Conv2DOptions.addDilationHFactor(builder, dilationHFactor);
    return Conv2DOptions.endConv2DOptions(builder);
  }

  unpack(): Conv2DOptionsT {
    return new Conv2DOptionsT(
        this.padding(), this.strideW(), this.strideH(), this.fusedActivationFunction(),
        this.dilationWFactor(), this.dilationHFactor());
  }


  unpackTo(_o: Conv2DOptionsT): void {
    _o.padding = this.padding();
    _o.strideW = this.strideW();
    _o.strideH = this.strideH();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.dilationWFactor = this.dilationWFactor();
    _o.dilationHFactor = this.dilationHFactor();
  }
}

export class Conv2DOptionsT {
  constructor(
      public padding: Padding = Padding.SAME, public strideW: number = 0,
      public strideH: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public dilationWFactor: number = 1, public dilationHFactor: number = 1) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return Conv2DOptions.createConv2DOptions(
        builder, this.padding, this.strideW, this.strideH, this.fusedActivationFunction,
        this.dilationWFactor, this.dilationHFactor);
  }
}

export class Conv3DOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Conv3DOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsConv3DOptions(bb: flatbuffers.ByteBuffer, obj?: Conv3DOptions): Conv3DOptions {
    return (obj || new Conv3DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsConv3DOptions(bb: flatbuffers.ByteBuffer, obj?: Conv3DOptions):
      Conv3DOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Conv3DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  padding(): Padding {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : Padding.SAME;
  }

  strideD(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideW(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideH(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  dilationDFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  dilationWFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  dilationHFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  static startConv3DOptions(builder: flatbuffers.Builder) {
    builder.startObject(8);
  }

  static addPadding(builder: flatbuffers.Builder, padding: Padding) {
    builder.addFieldInt8(0, padding, Padding.SAME);
  }

  static addStrideD(builder: flatbuffers.Builder, strideD: number) {
    builder.addFieldInt32(1, strideD, 0);
  }

  static addStrideW(builder: flatbuffers.Builder, strideW: number) {
    builder.addFieldInt32(2, strideW, 0);
  }

  static addStrideH(builder: flatbuffers.Builder, strideH: number) {
    builder.addFieldInt32(3, strideH, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(4, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addDilationDFactor(builder: flatbuffers.Builder, dilationDFactor: number) {
    builder.addFieldInt32(5, dilationDFactor, 1);
  }

  static addDilationWFactor(builder: flatbuffers.Builder, dilationWFactor: number) {
    builder.addFieldInt32(6, dilationWFactor, 1);
  }

  static addDilationHFactor(builder: flatbuffers.Builder, dilationHFactor: number) {
    builder.addFieldInt32(7, dilationHFactor, 1);
  }

  static endConv3DOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createConv3DOptions(
      builder: flatbuffers.Builder, padding: Padding, strideD: number, strideW: number,
      strideH: number, fusedActivationFunction: ActivationFunctionType, dilationDFactor: number,
      dilationWFactor: number, dilationHFactor: number): flatbuffers.Offset {
    Conv3DOptions.startConv3DOptions(builder);
    Conv3DOptions.addPadding(builder, padding);
    Conv3DOptions.addStrideD(builder, strideD);
    Conv3DOptions.addStrideW(builder, strideW);
    Conv3DOptions.addStrideH(builder, strideH);
    Conv3DOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    Conv3DOptions.addDilationDFactor(builder, dilationDFactor);
    Conv3DOptions.addDilationWFactor(builder, dilationWFactor);
    Conv3DOptions.addDilationHFactor(builder, dilationHFactor);
    return Conv3DOptions.endConv3DOptions(builder);
  }

  unpack(): Conv3DOptionsT {
    return new Conv3DOptionsT(
        this.padding(), this.strideD(), this.strideW(), this.strideH(),
        this.fusedActivationFunction(), this.dilationDFactor(), this.dilationWFactor(),
        this.dilationHFactor());
  }


  unpackTo(_o: Conv3DOptionsT): void {
    _o.padding = this.padding();
    _o.strideD = this.strideD();
    _o.strideW = this.strideW();
    _o.strideH = this.strideH();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.dilationDFactor = this.dilationDFactor();
    _o.dilationWFactor = this.dilationWFactor();
    _o.dilationHFactor = this.dilationHFactor();
  }
}

export class Conv3DOptionsT {
  constructor(
      public padding: Padding = Padding.SAME, public strideD: number = 0,
      public strideW: number = 0, public strideH: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public dilationDFactor: number = 1, public dilationWFactor: number = 1,
      public dilationHFactor: number = 1) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return Conv3DOptions.createConv3DOptions(
        builder, this.padding, this.strideD, this.strideW, this.strideH,
        this.fusedActivationFunction, this.dilationDFactor, this.dilationWFactor,
        this.dilationHFactor);
  }
}

export class Pool2DOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Pool2DOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsPool2DOptions(bb: flatbuffers.ByteBuffer, obj?: Pool2DOptions): Pool2DOptions {
    return (obj || new Pool2DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsPool2DOptions(bb: flatbuffers.ByteBuffer, obj?: Pool2DOptions):
      Pool2DOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Pool2DOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  padding(): Padding {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : Padding.SAME;
  }

  strideW(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideH(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  filterWidth(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  filterHeight(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startPool2DOptions(builder: flatbuffers.Builder) {
    builder.startObject(6);
  }

  static addPadding(builder: flatbuffers.Builder, padding: Padding) {
    builder.addFieldInt8(0, padding, Padding.SAME);
  }

  static addStrideW(builder: flatbuffers.Builder, strideW: number) {
    builder.addFieldInt32(1, strideW, 0);
  }

  static addStrideH(builder: flatbuffers.Builder, strideH: number) {
    builder.addFieldInt32(2, strideH, 0);
  }

  static addFilterWidth(builder: flatbuffers.Builder, filterWidth: number) {
    builder.addFieldInt32(3, filterWidth, 0);
  }

  static addFilterHeight(builder: flatbuffers.Builder, filterHeight: number) {
    builder.addFieldInt32(4, filterHeight, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(5, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endPool2DOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createPool2DOptions(
      builder: flatbuffers.Builder, padding: Padding, strideW: number, strideH: number,
      filterWidth: number, filterHeight: number,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    Pool2DOptions.startPool2DOptions(builder);
    Pool2DOptions.addPadding(builder, padding);
    Pool2DOptions.addStrideW(builder, strideW);
    Pool2DOptions.addStrideH(builder, strideH);
    Pool2DOptions.addFilterWidth(builder, filterWidth);
    Pool2DOptions.addFilterHeight(builder, filterHeight);
    Pool2DOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return Pool2DOptions.endPool2DOptions(builder);
  }

  unpack(): Pool2DOptionsT {
    return new Pool2DOptionsT(
        this.padding(), this.strideW(), this.strideH(), this.filterWidth(), this.filterHeight(),
        this.fusedActivationFunction());
  }


  unpackTo(_o: Pool2DOptionsT): void {
    _o.padding = this.padding();
    _o.strideW = this.strideW();
    _o.strideH = this.strideH();
    _o.filterWidth = this.filterWidth();
    _o.filterHeight = this.filterHeight();
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class Pool2DOptionsT {
  constructor(
      public padding: Padding = Padding.SAME, public strideW: number = 0,
      public strideH: number = 0, public filterWidth: number = 0, public filterHeight: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return Pool2DOptions.createPool2DOptions(
        builder, this.padding, this.strideW, this.strideH, this.filterWidth, this.filterHeight,
        this.fusedActivationFunction);
  }
}

export class DepthwiseConv2DOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DepthwiseConv2DOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDepthwiseConv2DOptions(bb: flatbuffers.ByteBuffer, obj?: DepthwiseConv2DOptions):
      DepthwiseConv2DOptions {
    return (obj || new DepthwiseConv2DOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDepthwiseConv2DOptions(
      bb: flatbuffers.ByteBuffer, obj?: DepthwiseConv2DOptions): DepthwiseConv2DOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DepthwiseConv2DOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  padding(): Padding {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : Padding.SAME;
  }

  strideW(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideH(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  depthMultiplier(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  dilationWFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  dilationHFactor(): number {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  static startDepthwiseConv2DOptions(builder: flatbuffers.Builder) {
    builder.startObject(7);
  }

  static addPadding(builder: flatbuffers.Builder, padding: Padding) {
    builder.addFieldInt8(0, padding, Padding.SAME);
  }

  static addStrideW(builder: flatbuffers.Builder, strideW: number) {
    builder.addFieldInt32(1, strideW, 0);
  }

  static addStrideH(builder: flatbuffers.Builder, strideH: number) {
    builder.addFieldInt32(2, strideH, 0);
  }

  static addDepthMultiplier(builder: flatbuffers.Builder, depthMultiplier: number) {
    builder.addFieldInt32(3, depthMultiplier, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(4, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addDilationWFactor(builder: flatbuffers.Builder, dilationWFactor: number) {
    builder.addFieldInt32(5, dilationWFactor, 1);
  }

  static addDilationHFactor(builder: flatbuffers.Builder, dilationHFactor: number) {
    builder.addFieldInt32(6, dilationHFactor, 1);
  }

  static endDepthwiseConv2DOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDepthwiseConv2DOptions(
      builder: flatbuffers.Builder, padding: Padding, strideW: number, strideH: number,
      depthMultiplier: number, fusedActivationFunction: ActivationFunctionType,
      dilationWFactor: number, dilationHFactor: number): flatbuffers.Offset {
    DepthwiseConv2DOptions.startDepthwiseConv2DOptions(builder);
    DepthwiseConv2DOptions.addPadding(builder, padding);
    DepthwiseConv2DOptions.addStrideW(builder, strideW);
    DepthwiseConv2DOptions.addStrideH(builder, strideH);
    DepthwiseConv2DOptions.addDepthMultiplier(builder, depthMultiplier);
    DepthwiseConv2DOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    DepthwiseConv2DOptions.addDilationWFactor(builder, dilationWFactor);
    DepthwiseConv2DOptions.addDilationHFactor(builder, dilationHFactor);
    return DepthwiseConv2DOptions.endDepthwiseConv2DOptions(builder);
  }

  unpack(): DepthwiseConv2DOptionsT {
    return new DepthwiseConv2DOptionsT(
        this.padding(), this.strideW(), this.strideH(), this.depthMultiplier(),
        this.fusedActivationFunction(), this.dilationWFactor(), this.dilationHFactor());
  }


  unpackTo(_o: DepthwiseConv2DOptionsT): void {
    _o.padding = this.padding();
    _o.strideW = this.strideW();
    _o.strideH = this.strideH();
    _o.depthMultiplier = this.depthMultiplier();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.dilationWFactor = this.dilationWFactor();
    _o.dilationHFactor = this.dilationHFactor();
  }
}

export class DepthwiseConv2DOptionsT {
  constructor(
      public padding: Padding = Padding.SAME, public strideW: number = 0,
      public strideH: number = 0, public depthMultiplier: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public dilationWFactor: number = 1, public dilationHFactor: number = 1) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DepthwiseConv2DOptions.createDepthwiseConv2DOptions(
        builder, this.padding, this.strideW, this.strideH, this.depthMultiplier,
        this.fusedActivationFunction, this.dilationWFactor, this.dilationHFactor);
  }
}

export class ConcatEmbeddingsOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ConcatEmbeddingsOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsConcatEmbeddingsOptions(
      bb: flatbuffers.ByteBuffer, obj?: ConcatEmbeddingsOptions): ConcatEmbeddingsOptions {
    return (obj || new ConcatEmbeddingsOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsConcatEmbeddingsOptions(
      bb: flatbuffers.ByteBuffer, obj?: ConcatEmbeddingsOptions): ConcatEmbeddingsOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ConcatEmbeddingsOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  numChannels(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  numColumnsPerChannel(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  numColumnsPerChannelLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  numColumnsPerChannelArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  embeddingDimPerChannel(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  embeddingDimPerChannelLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  embeddingDimPerChannelArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startConcatEmbeddingsOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addNumChannels(builder: flatbuffers.Builder, numChannels: number) {
    builder.addFieldInt32(0, numChannels, 0);
  }

  static addNumColumnsPerChannel(
      builder: flatbuffers.Builder, numColumnsPerChannelOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, numColumnsPerChannelOffset, 0);
  }

  static createNumColumnsPerChannelVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createNumColumnsPerChannelVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createNumColumnsPerChannelVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startNumColumnsPerChannelVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addEmbeddingDimPerChannel(
      builder: flatbuffers.Builder, embeddingDimPerChannelOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, embeddingDimPerChannelOffset, 0);
  }

  static createEmbeddingDimPerChannelVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array): flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createEmbeddingDimPerChannelVector(
      builder: flatbuffers.Builder, data: number[]|Uint8Array): flatbuffers.Offset;
  static createEmbeddingDimPerChannelVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startEmbeddingDimPerChannelVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endConcatEmbeddingsOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createConcatEmbeddingsOptions(
      builder: flatbuffers.Builder, numChannels: number,
      numColumnsPerChannelOffset: flatbuffers.Offset,
      embeddingDimPerChannelOffset: flatbuffers.Offset): flatbuffers.Offset {
    ConcatEmbeddingsOptions.startConcatEmbeddingsOptions(builder);
    ConcatEmbeddingsOptions.addNumChannels(builder, numChannels);
    ConcatEmbeddingsOptions.addNumColumnsPerChannel(builder, numColumnsPerChannelOffset);
    ConcatEmbeddingsOptions.addEmbeddingDimPerChannel(builder, embeddingDimPerChannelOffset);
    return ConcatEmbeddingsOptions.endConcatEmbeddingsOptions(builder);
  }

  unpack(): ConcatEmbeddingsOptionsT {
    return new ConcatEmbeddingsOptionsT(
        this.numChannels(),
        this.bb!.createScalarList(
            this.numColumnsPerChannel.bind(this), this.numColumnsPerChannelLength()),
        this.bb!.createScalarList(
            this.embeddingDimPerChannel.bind(this), this.embeddingDimPerChannelLength()));
  }


  unpackTo(_o: ConcatEmbeddingsOptionsT): void {
    _o.numChannels = this.numChannels();
    _o.numColumnsPerChannel = this.bb!.createScalarList(
        this.numColumnsPerChannel.bind(this), this.numColumnsPerChannelLength());
    _o.embeddingDimPerChannel = this.bb!.createScalarList(
        this.embeddingDimPerChannel.bind(this), this.embeddingDimPerChannelLength());
  }
}

export class ConcatEmbeddingsOptionsT {
  constructor(
      public numChannels: number = 0, public numColumnsPerChannel: (number)[] = [],
      public embeddingDimPerChannel: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const numColumnsPerChannel = ConcatEmbeddingsOptions.createNumColumnsPerChannelVector(
        builder, this.numColumnsPerChannel);
    const embeddingDimPerChannel = ConcatEmbeddingsOptions.createEmbeddingDimPerChannelVector(
        builder, this.embeddingDimPerChannel);

    return ConcatEmbeddingsOptions.createConcatEmbeddingsOptions(
        builder, this.numChannels, numColumnsPerChannel, embeddingDimPerChannel);
  }
}

export class LSHProjectionOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LSHProjectionOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLSHProjectionOptions(bb: flatbuffers.ByteBuffer, obj?: LSHProjectionOptions):
      LSHProjectionOptions {
    return (obj || new LSHProjectionOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLSHProjectionOptions(
      bb: flatbuffers.ByteBuffer, obj?: LSHProjectionOptions): LSHProjectionOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LSHProjectionOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  type(): LSHProjectionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : LSHProjectionType.UNKNOWN;
  }

  static startLSHProjectionOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addType(builder: flatbuffers.Builder, type: LSHProjectionType) {
    builder.addFieldInt8(0, type, LSHProjectionType.UNKNOWN);
  }

  static endLSHProjectionOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLSHProjectionOptions(builder: flatbuffers.Builder, type: LSHProjectionType):
      flatbuffers.Offset {
    LSHProjectionOptions.startLSHProjectionOptions(builder);
    LSHProjectionOptions.addType(builder, type);
    return LSHProjectionOptions.endLSHProjectionOptions(builder);
  }

  unpack(): LSHProjectionOptionsT {
    return new LSHProjectionOptionsT(this.type());
  }


  unpackTo(_o: LSHProjectionOptionsT): void {
    _o.type = this.type();
  }
}

export class LSHProjectionOptionsT {
  constructor(public type: LSHProjectionType = LSHProjectionType.UNKNOWN) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LSHProjectionOptions.createLSHProjectionOptions(builder, this.type);
  }
}

export class SVDFOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SVDFOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSVDFOptions(bb: flatbuffers.ByteBuffer, obj?: SVDFOptions): SVDFOptions {
    return (obj || new SVDFOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSVDFOptions(bb: flatbuffers.ByteBuffer, obj?: SVDFOptions):
      SVDFOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SVDFOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  rank(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startSVDFOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addRank(builder: flatbuffers.Builder, rank: number) {
    builder.addFieldInt32(0, rank, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(2, +asymmetricQuantizeInputs, +false);
  }

  static endSVDFOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSVDFOptions(
      builder: flatbuffers.Builder, rank: number, fusedActivationFunction: ActivationFunctionType,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    SVDFOptions.startSVDFOptions(builder);
    SVDFOptions.addRank(builder, rank);
    SVDFOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    SVDFOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return SVDFOptions.endSVDFOptions(builder);
  }

  unpack(): SVDFOptionsT {
    return new SVDFOptionsT(
        this.rank(), this.fusedActivationFunction(), this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: SVDFOptionsT): void {
    _o.rank = this.rank();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class SVDFOptionsT {
  constructor(
      public rank: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SVDFOptions.createSVDFOptions(
        builder, this.rank, this.fusedActivationFunction, this.asymmetricQuantizeInputs);
  }
}

export class RNNOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): RNNOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsRNNOptions(bb: flatbuffers.ByteBuffer, obj?: RNNOptions): RNNOptions {
    return (obj || new RNNOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsRNNOptions(bb: flatbuffers.ByteBuffer, obj?: RNNOptions): RNNOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new RNNOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startRNNOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(1, +asymmetricQuantizeInputs, +false);
  }

  static endRNNOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createRNNOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    RNNOptions.startRNNOptions(builder);
    RNNOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    RNNOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return RNNOptions.endRNNOptions(builder);
  }

  unpack(): RNNOptionsT {
    return new RNNOptionsT(this.fusedActivationFunction(), this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: RNNOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class RNNOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return RNNOptions.createRNNOptions(
        builder, this.fusedActivationFunction, this.asymmetricQuantizeInputs);
  }
}

export class SequenceRNNOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SequenceRNNOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSequenceRNNOptions(bb: flatbuffers.ByteBuffer, obj?: SequenceRNNOptions):
      SequenceRNNOptions {
    return (obj || new SequenceRNNOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSequenceRNNOptions(
      bb: flatbuffers.ByteBuffer, obj?: SequenceRNNOptions): SequenceRNNOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SequenceRNNOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  timeMajor(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startSequenceRNNOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addTimeMajor(builder: flatbuffers.Builder, timeMajor: boolean) {
    builder.addFieldInt8(0, +timeMajor, +false);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(2, +asymmetricQuantizeInputs, +false);
  }

  static endSequenceRNNOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSequenceRNNOptions(
      builder: flatbuffers.Builder, timeMajor: boolean,
      fusedActivationFunction: ActivationFunctionType,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    SequenceRNNOptions.startSequenceRNNOptions(builder);
    SequenceRNNOptions.addTimeMajor(builder, timeMajor);
    SequenceRNNOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    SequenceRNNOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return SequenceRNNOptions.endSequenceRNNOptions(builder);
  }

  unpack(): SequenceRNNOptionsT {
    return new SequenceRNNOptionsT(
        this.timeMajor(), this.fusedActivationFunction(), this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: SequenceRNNOptionsT): void {
    _o.timeMajor = this.timeMajor();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class SequenceRNNOptionsT {
  constructor(
      public timeMajor: boolean = false,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SequenceRNNOptions.createSequenceRNNOptions(
        builder, this.timeMajor, this.fusedActivationFunction, this.asymmetricQuantizeInputs);
  }
}

export class BidirectionalSequenceRNNOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BidirectionalSequenceRNNOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBidirectionalSequenceRNNOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: BidirectionalSequenceRNNOptions): BidirectionalSequenceRNNOptions {
    return (obj || new BidirectionalSequenceRNNOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBidirectionalSequenceRNNOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: BidirectionalSequenceRNNOptions): BidirectionalSequenceRNNOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BidirectionalSequenceRNNOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  timeMajor(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  mergeOutputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startBidirectionalSequenceRNNOptions(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addTimeMajor(builder: flatbuffers.Builder, timeMajor: boolean) {
    builder.addFieldInt8(0, +timeMajor, +false);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addMergeOutputs(builder: flatbuffers.Builder, mergeOutputs: boolean) {
    builder.addFieldInt8(2, +mergeOutputs, +false);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(3, +asymmetricQuantizeInputs, +false);
  }

  static endBidirectionalSequenceRNNOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBidirectionalSequenceRNNOptions(
      builder: flatbuffers.Builder, timeMajor: boolean,
      fusedActivationFunction: ActivationFunctionType, mergeOutputs: boolean,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    BidirectionalSequenceRNNOptions.startBidirectionalSequenceRNNOptions(builder);
    BidirectionalSequenceRNNOptions.addTimeMajor(builder, timeMajor);
    BidirectionalSequenceRNNOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    BidirectionalSequenceRNNOptions.addMergeOutputs(builder, mergeOutputs);
    BidirectionalSequenceRNNOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return BidirectionalSequenceRNNOptions.endBidirectionalSequenceRNNOptions(builder);
  }

  unpack(): BidirectionalSequenceRNNOptionsT {
    return new BidirectionalSequenceRNNOptionsT(
        this.timeMajor(), this.fusedActivationFunction(), this.mergeOutputs(),
        this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: BidirectionalSequenceRNNOptionsT): void {
    _o.timeMajor = this.timeMajor();
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.mergeOutputs = this.mergeOutputs();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class BidirectionalSequenceRNNOptionsT {
  constructor(
      public timeMajor: boolean = false,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public mergeOutputs: boolean = false, public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BidirectionalSequenceRNNOptions.createBidirectionalSequenceRNNOptions(
        builder, this.timeMajor, this.fusedActivationFunction, this.mergeOutputs,
        this.asymmetricQuantizeInputs);
  }
}

export class FullyConnectedOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): FullyConnectedOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsFullyConnectedOptions(bb: flatbuffers.ByteBuffer, obj?: FullyConnectedOptions):
      FullyConnectedOptions {
    return (obj || new FullyConnectedOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFullyConnectedOptions(
      bb: flatbuffers.ByteBuffer, obj?: FullyConnectedOptions): FullyConnectedOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new FullyConnectedOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  weightsFormat(): FullyConnectedOptionsWeightsFormat {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) :
                    FullyConnectedOptionsWeightsFormat.DEFAULT;
  }

  keepNumDims(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startFullyConnectedOptions(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addWeightsFormat(
      builder: flatbuffers.Builder, weightsFormat: FullyConnectedOptionsWeightsFormat) {
    builder.addFieldInt8(1, weightsFormat, FullyConnectedOptionsWeightsFormat.DEFAULT);
  }

  static addKeepNumDims(builder: flatbuffers.Builder, keepNumDims: boolean) {
    builder.addFieldInt8(2, +keepNumDims, +false);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(3, +asymmetricQuantizeInputs, +false);
  }

  static endFullyConnectedOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createFullyConnectedOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      weightsFormat: FullyConnectedOptionsWeightsFormat, keepNumDims: boolean,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    FullyConnectedOptions.startFullyConnectedOptions(builder);
    FullyConnectedOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    FullyConnectedOptions.addWeightsFormat(builder, weightsFormat);
    FullyConnectedOptions.addKeepNumDims(builder, keepNumDims);
    FullyConnectedOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return FullyConnectedOptions.endFullyConnectedOptions(builder);
  }

  unpack(): FullyConnectedOptionsT {
    return new FullyConnectedOptionsT(
        this.fusedActivationFunction(), this.weightsFormat(), this.keepNumDims(),
        this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: FullyConnectedOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.weightsFormat = this.weightsFormat();
    _o.keepNumDims = this.keepNumDims();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class FullyConnectedOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public weightsFormat:
          FullyConnectedOptionsWeightsFormat = FullyConnectedOptionsWeightsFormat.DEFAULT,
      public keepNumDims: boolean = false, public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return FullyConnectedOptions.createFullyConnectedOptions(
        builder, this.fusedActivationFunction, this.weightsFormat, this.keepNumDims,
        this.asymmetricQuantizeInputs);
  }
}

export class SoftmaxOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SoftmaxOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSoftmaxOptions(bb: flatbuffers.ByteBuffer, obj?: SoftmaxOptions): SoftmaxOptions {
    return (obj || new SoftmaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSoftmaxOptions(bb: flatbuffers.ByteBuffer, obj?: SoftmaxOptions):
      SoftmaxOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SoftmaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  beta(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  static startSoftmaxOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addBeta(builder: flatbuffers.Builder, beta: number) {
    builder.addFieldFloat32(0, beta, 0.0);
  }

  static endSoftmaxOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSoftmaxOptions(builder: flatbuffers.Builder, beta: number): flatbuffers.Offset {
    SoftmaxOptions.startSoftmaxOptions(builder);
    SoftmaxOptions.addBeta(builder, beta);
    return SoftmaxOptions.endSoftmaxOptions(builder);
  }

  unpack(): SoftmaxOptionsT {
    return new SoftmaxOptionsT(this.beta());
  }


  unpackTo(_o: SoftmaxOptionsT): void {
    _o.beta = this.beta();
  }
}

export class SoftmaxOptionsT {
  constructor(public beta: number = 0.0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SoftmaxOptions.createSoftmaxOptions(builder, this.beta);
  }
}

export class ConcatenationOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ConcatenationOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsConcatenationOptions(bb: flatbuffers.ByteBuffer, obj?: ConcatenationOptions):
      ConcatenationOptions {
    return (obj || new ConcatenationOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsConcatenationOptions(
      bb: flatbuffers.ByteBuffer, obj?: ConcatenationOptions): ConcatenationOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ConcatenationOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startConcatenationOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(0, axis, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endConcatenationOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createConcatenationOptions(
      builder: flatbuffers.Builder, axis: number,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    ConcatenationOptions.startConcatenationOptions(builder);
    ConcatenationOptions.addAxis(builder, axis);
    ConcatenationOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return ConcatenationOptions.endConcatenationOptions(builder);
  }

  unpack(): ConcatenationOptionsT {
    return new ConcatenationOptionsT(this.axis(), this.fusedActivationFunction());
  }


  unpackTo(_o: ConcatenationOptionsT): void {
    _o.axis = this.axis();
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class ConcatenationOptionsT {
  constructor(
      public axis: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ConcatenationOptions.createConcatenationOptions(
        builder, this.axis, this.fusedActivationFunction);
  }
}

export class AddOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): AddOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsAddOptions(bb: flatbuffers.ByteBuffer, obj?: AddOptions): AddOptions {
    return (obj || new AddOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsAddOptions(bb: flatbuffers.ByteBuffer, obj?: AddOptions): AddOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new AddOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  potScaleInt16(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
  }

  static startAddOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addPotScaleInt16(builder: flatbuffers.Builder, potScaleInt16: boolean) {
    builder.addFieldInt8(1, +potScaleInt16, +true);
  }

  static endAddOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createAddOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      potScaleInt16: boolean): flatbuffers.Offset {
    AddOptions.startAddOptions(builder);
    AddOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    AddOptions.addPotScaleInt16(builder, potScaleInt16);
    return AddOptions.endAddOptions(builder);
  }

  unpack(): AddOptionsT {
    return new AddOptionsT(this.fusedActivationFunction(), this.potScaleInt16());
  }


  unpackTo(_o: AddOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.potScaleInt16 = this.potScaleInt16();
  }
}

export class AddOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public potScaleInt16: boolean = true) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return AddOptions.createAddOptions(builder, this.fusedActivationFunction, this.potScaleInt16);
  }
}

export class MulOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): MulOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMulOptions(bb: flatbuffers.ByteBuffer, obj?: MulOptions): MulOptions {
    return (obj || new MulOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMulOptions(bb: flatbuffers.ByteBuffer, obj?: MulOptions): MulOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new MulOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startMulOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endMulOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMulOptions(
      builder: flatbuffers.Builder,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    MulOptions.startMulOptions(builder);
    MulOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return MulOptions.endMulOptions(builder);
  }

  unpack(): MulOptionsT {
    return new MulOptionsT(this.fusedActivationFunction());
  }


  unpackTo(_o: MulOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class MulOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return MulOptions.createMulOptions(builder, this.fusedActivationFunction);
  }
}

export class L2NormOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): L2NormOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsL2NormOptions(bb: flatbuffers.ByteBuffer, obj?: L2NormOptions): L2NormOptions {
    return (obj || new L2NormOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsL2NormOptions(bb: flatbuffers.ByteBuffer, obj?: L2NormOptions):
      L2NormOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new L2NormOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startL2NormOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endL2NormOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createL2NormOptions(
      builder: flatbuffers.Builder,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    L2NormOptions.startL2NormOptions(builder);
    L2NormOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return L2NormOptions.endL2NormOptions(builder);
  }

  unpack(): L2NormOptionsT {
    return new L2NormOptionsT(this.fusedActivationFunction());
  }


  unpackTo(_o: L2NormOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class L2NormOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return L2NormOptions.createL2NormOptions(builder, this.fusedActivationFunction);
  }
}

export class LocalResponseNormalizationOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LocalResponseNormalizationOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLocalResponseNormalizationOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: LocalResponseNormalizationOptions): LocalResponseNormalizationOptions {
    return (obj || new LocalResponseNormalizationOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLocalResponseNormalizationOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: LocalResponseNormalizationOptions): LocalResponseNormalizationOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LocalResponseNormalizationOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  radius(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  bias(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  alpha(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  beta(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  static startLocalResponseNormalizationOptions(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addRadius(builder: flatbuffers.Builder, radius: number) {
    builder.addFieldInt32(0, radius, 0);
  }

  static addBias(builder: flatbuffers.Builder, bias: number) {
    builder.addFieldFloat32(1, bias, 0.0);
  }

  static addAlpha(builder: flatbuffers.Builder, alpha: number) {
    builder.addFieldFloat32(2, alpha, 0.0);
  }

  static addBeta(builder: flatbuffers.Builder, beta: number) {
    builder.addFieldFloat32(3, beta, 0.0);
  }

  static endLocalResponseNormalizationOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLocalResponseNormalizationOptions(
      builder: flatbuffers.Builder, radius: number, bias: number, alpha: number,
      beta: number): flatbuffers.Offset {
    LocalResponseNormalizationOptions.startLocalResponseNormalizationOptions(builder);
    LocalResponseNormalizationOptions.addRadius(builder, radius);
    LocalResponseNormalizationOptions.addBias(builder, bias);
    LocalResponseNormalizationOptions.addAlpha(builder, alpha);
    LocalResponseNormalizationOptions.addBeta(builder, beta);
    return LocalResponseNormalizationOptions.endLocalResponseNormalizationOptions(builder);
  }

  unpack(): LocalResponseNormalizationOptionsT {
    return new LocalResponseNormalizationOptionsT(
        this.radius(), this.bias(), this.alpha(), this.beta());
  }


  unpackTo(_o: LocalResponseNormalizationOptionsT): void {
    _o.radius = this.radius();
    _o.bias = this.bias();
    _o.alpha = this.alpha();
    _o.beta = this.beta();
  }
}

export class LocalResponseNormalizationOptionsT {
  constructor(
      public radius: number = 0, public bias: number = 0.0, public alpha: number = 0.0,
      public beta: number = 0.0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LocalResponseNormalizationOptions.createLocalResponseNormalizationOptions(
        builder, this.radius, this.bias, this.alpha, this.beta);
  }
}

export class LSTMOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LSTMOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLSTMOptions(bb: flatbuffers.ByteBuffer, obj?: LSTMOptions): LSTMOptions {
    return (obj || new LSTMOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLSTMOptions(bb: flatbuffers.ByteBuffer, obj?: LSTMOptions):
      LSTMOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LSTMOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  cellClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  projClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  kernelType(): LSTMKernelType {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : LSTMKernelType.FULL;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startLSTMOptions(builder: flatbuffers.Builder) {
    builder.startObject(5);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addCellClip(builder: flatbuffers.Builder, cellClip: number) {
    builder.addFieldFloat32(1, cellClip, 0.0);
  }

  static addProjClip(builder: flatbuffers.Builder, projClip: number) {
    builder.addFieldFloat32(2, projClip, 0.0);
  }

  static addKernelType(builder: flatbuffers.Builder, kernelType: LSTMKernelType) {
    builder.addFieldInt8(3, kernelType, LSTMKernelType.FULL);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(4, +asymmetricQuantizeInputs, +false);
  }

  static endLSTMOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLSTMOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      cellClip: number, projClip: number, kernelType: LSTMKernelType,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    LSTMOptions.startLSTMOptions(builder);
    LSTMOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    LSTMOptions.addCellClip(builder, cellClip);
    LSTMOptions.addProjClip(builder, projClip);
    LSTMOptions.addKernelType(builder, kernelType);
    LSTMOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return LSTMOptions.endLSTMOptions(builder);
  }

  unpack(): LSTMOptionsT {
    return new LSTMOptionsT(
        this.fusedActivationFunction(), this.cellClip(), this.projClip(), this.kernelType(),
        this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: LSTMOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.cellClip = this.cellClip();
    _o.projClip = this.projClip();
    _o.kernelType = this.kernelType();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class LSTMOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public cellClip: number = 0.0, public projClip: number = 0.0,
      public kernelType: LSTMKernelType = LSTMKernelType.FULL,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LSTMOptions.createLSTMOptions(
        builder, this.fusedActivationFunction, this.cellClip, this.projClip, this.kernelType,
        this.asymmetricQuantizeInputs);
  }
}

export class UnidirectionalSequenceLSTMOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): UnidirectionalSequenceLSTMOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsUnidirectionalSequenceLSTMOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: UnidirectionalSequenceLSTMOptions): UnidirectionalSequenceLSTMOptions {
    return (obj || new UnidirectionalSequenceLSTMOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsUnidirectionalSequenceLSTMOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: UnidirectionalSequenceLSTMOptions): UnidirectionalSequenceLSTMOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new UnidirectionalSequenceLSTMOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  cellClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  projClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  timeMajor(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startUnidirectionalSequenceLSTMOptions(builder: flatbuffers.Builder) {
    builder.startObject(5);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addCellClip(builder: flatbuffers.Builder, cellClip: number) {
    builder.addFieldFloat32(1, cellClip, 0.0);
  }

  static addProjClip(builder: flatbuffers.Builder, projClip: number) {
    builder.addFieldFloat32(2, projClip, 0.0);
  }

  static addTimeMajor(builder: flatbuffers.Builder, timeMajor: boolean) {
    builder.addFieldInt8(3, +timeMajor, +false);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(4, +asymmetricQuantizeInputs, +false);
  }

  static endUnidirectionalSequenceLSTMOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createUnidirectionalSequenceLSTMOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      cellClip: number, projClip: number, timeMajor: boolean,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    UnidirectionalSequenceLSTMOptions.startUnidirectionalSequenceLSTMOptions(builder);
    UnidirectionalSequenceLSTMOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    UnidirectionalSequenceLSTMOptions.addCellClip(builder, cellClip);
    UnidirectionalSequenceLSTMOptions.addProjClip(builder, projClip);
    UnidirectionalSequenceLSTMOptions.addTimeMajor(builder, timeMajor);
    UnidirectionalSequenceLSTMOptions.addAsymmetricQuantizeInputs(
        builder, asymmetricQuantizeInputs);
    return UnidirectionalSequenceLSTMOptions.endUnidirectionalSequenceLSTMOptions(builder);
  }

  unpack(): UnidirectionalSequenceLSTMOptionsT {
    return new UnidirectionalSequenceLSTMOptionsT(
        this.fusedActivationFunction(), this.cellClip(), this.projClip(), this.timeMajor(),
        this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: UnidirectionalSequenceLSTMOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.cellClip = this.cellClip();
    _o.projClip = this.projClip();
    _o.timeMajor = this.timeMajor();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class UnidirectionalSequenceLSTMOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public cellClip: number = 0.0, public projClip: number = 0.0,
      public timeMajor: boolean = false, public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return UnidirectionalSequenceLSTMOptions.createUnidirectionalSequenceLSTMOptions(
        builder, this.fusedActivationFunction, this.cellClip, this.projClip, this.timeMajor,
        this.asymmetricQuantizeInputs);
  }
}

export class BidirectionalSequenceLSTMOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BidirectionalSequenceLSTMOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBidirectionalSequenceLSTMOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: BidirectionalSequenceLSTMOptions): BidirectionalSequenceLSTMOptions {
    return (obj || new BidirectionalSequenceLSTMOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBidirectionalSequenceLSTMOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: BidirectionalSequenceLSTMOptions): BidirectionalSequenceLSTMOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BidirectionalSequenceLSTMOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  cellClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  projClip(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  mergeOutputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  timeMajor(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startBidirectionalSequenceLSTMOptions(builder: flatbuffers.Builder) {
    builder.startObject(6);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addCellClip(builder: flatbuffers.Builder, cellClip: number) {
    builder.addFieldFloat32(1, cellClip, 0.0);
  }

  static addProjClip(builder: flatbuffers.Builder, projClip: number) {
    builder.addFieldFloat32(2, projClip, 0.0);
  }

  static addMergeOutputs(builder: flatbuffers.Builder, mergeOutputs: boolean) {
    builder.addFieldInt8(3, +mergeOutputs, +false);
  }

  static addTimeMajor(builder: flatbuffers.Builder, timeMajor: boolean) {
    builder.addFieldInt8(4, +timeMajor, +true);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(5, +asymmetricQuantizeInputs, +false);
  }

  static endBidirectionalSequenceLSTMOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBidirectionalSequenceLSTMOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      cellClip: number, projClip: number, mergeOutputs: boolean, timeMajor: boolean,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    BidirectionalSequenceLSTMOptions.startBidirectionalSequenceLSTMOptions(builder);
    BidirectionalSequenceLSTMOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    BidirectionalSequenceLSTMOptions.addCellClip(builder, cellClip);
    BidirectionalSequenceLSTMOptions.addProjClip(builder, projClip);
    BidirectionalSequenceLSTMOptions.addMergeOutputs(builder, mergeOutputs);
    BidirectionalSequenceLSTMOptions.addTimeMajor(builder, timeMajor);
    BidirectionalSequenceLSTMOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return BidirectionalSequenceLSTMOptions.endBidirectionalSequenceLSTMOptions(builder);
  }

  unpack(): BidirectionalSequenceLSTMOptionsT {
    return new BidirectionalSequenceLSTMOptionsT(
        this.fusedActivationFunction(), this.cellClip(), this.projClip(), this.mergeOutputs(),
        this.timeMajor(), this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: BidirectionalSequenceLSTMOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.cellClip = this.cellClip();
    _o.projClip = this.projClip();
    _o.mergeOutputs = this.mergeOutputs();
    _o.timeMajor = this.timeMajor();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class BidirectionalSequenceLSTMOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public cellClip: number = 0.0, public projClip: number = 0.0,
      public mergeOutputs: boolean = false, public timeMajor: boolean = true,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BidirectionalSequenceLSTMOptions.createBidirectionalSequenceLSTMOptions(
        builder, this.fusedActivationFunction, this.cellClip, this.projClip, this.mergeOutputs,
        this.timeMajor, this.asymmetricQuantizeInputs);
  }
}

export class ResizeBilinearOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ResizeBilinearOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsResizeBilinearOptions(bb: flatbuffers.ByteBuffer, obj?: ResizeBilinearOptions):
      ResizeBilinearOptions {
    return (obj || new ResizeBilinearOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsResizeBilinearOptions(
      bb: flatbuffers.ByteBuffer, obj?: ResizeBilinearOptions): ResizeBilinearOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ResizeBilinearOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  alignCorners(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  halfPixelCenters(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startResizeBilinearOptions(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addAlignCorners(builder: flatbuffers.Builder, alignCorners: boolean) {
    builder.addFieldInt8(2, +alignCorners, +false);
  }

  static addHalfPixelCenters(builder: flatbuffers.Builder, halfPixelCenters: boolean) {
    builder.addFieldInt8(3, +halfPixelCenters, +false);
  }

  static endResizeBilinearOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createResizeBilinearOptions(
      builder: flatbuffers.Builder, alignCorners: boolean,
      halfPixelCenters: boolean): flatbuffers.Offset {
    ResizeBilinearOptions.startResizeBilinearOptions(builder);
    ResizeBilinearOptions.addAlignCorners(builder, alignCorners);
    ResizeBilinearOptions.addHalfPixelCenters(builder, halfPixelCenters);
    return ResizeBilinearOptions.endResizeBilinearOptions(builder);
  }

  unpack(): ResizeBilinearOptionsT {
    return new ResizeBilinearOptionsT(this.alignCorners(), this.halfPixelCenters());
  }


  unpackTo(_o: ResizeBilinearOptionsT): void {
    _o.alignCorners = this.alignCorners();
    _o.halfPixelCenters = this.halfPixelCenters();
  }
}

export class ResizeBilinearOptionsT {
  constructor(public alignCorners: boolean = false, public halfPixelCenters: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ResizeBilinearOptions.createResizeBilinearOptions(
        builder, this.alignCorners, this.halfPixelCenters);
  }
}

export class ResizeNearestNeighborOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ResizeNearestNeighborOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsResizeNearestNeighborOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: ResizeNearestNeighborOptions): ResizeNearestNeighborOptions {
    return (obj || new ResizeNearestNeighborOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsResizeNearestNeighborOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: ResizeNearestNeighborOptions): ResizeNearestNeighborOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ResizeNearestNeighborOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  alignCorners(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  halfPixelCenters(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startResizeNearestNeighborOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addAlignCorners(builder: flatbuffers.Builder, alignCorners: boolean) {
    builder.addFieldInt8(0, +alignCorners, +false);
  }

  static addHalfPixelCenters(builder: flatbuffers.Builder, halfPixelCenters: boolean) {
    builder.addFieldInt8(1, +halfPixelCenters, +false);
  }

  static endResizeNearestNeighborOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createResizeNearestNeighborOptions(
      builder: flatbuffers.Builder, alignCorners: boolean,
      halfPixelCenters: boolean): flatbuffers.Offset {
    ResizeNearestNeighborOptions.startResizeNearestNeighborOptions(builder);
    ResizeNearestNeighborOptions.addAlignCorners(builder, alignCorners);
    ResizeNearestNeighborOptions.addHalfPixelCenters(builder, halfPixelCenters);
    return ResizeNearestNeighborOptions.endResizeNearestNeighborOptions(builder);
  }

  unpack(): ResizeNearestNeighborOptionsT {
    return new ResizeNearestNeighborOptionsT(this.alignCorners(), this.halfPixelCenters());
  }


  unpackTo(_o: ResizeNearestNeighborOptionsT): void {
    _o.alignCorners = this.alignCorners();
    _o.halfPixelCenters = this.halfPixelCenters();
  }
}

export class ResizeNearestNeighborOptionsT {
  constructor(public alignCorners: boolean = false, public halfPixelCenters: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ResizeNearestNeighborOptions.createResizeNearestNeighborOptions(
        builder, this.alignCorners, this.halfPixelCenters);
  }
}

export class CallOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CallOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCallOptions(bb: flatbuffers.ByteBuffer, obj?: CallOptions): CallOptions {
    return (obj || new CallOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCallOptions(bb: flatbuffers.ByteBuffer, obj?: CallOptions):
      CallOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CallOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  subgraph(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  static startCallOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addSubgraph(builder: flatbuffers.Builder, subgraph: number) {
    builder.addFieldInt32(0, subgraph, 0);
  }

  static endCallOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCallOptions(builder: flatbuffers.Builder, subgraph: number): flatbuffers.Offset {
    CallOptions.startCallOptions(builder);
    CallOptions.addSubgraph(builder, subgraph);
    return CallOptions.endCallOptions(builder);
  }

  unpack(): CallOptionsT {
    return new CallOptionsT(this.subgraph());
  }


  unpackTo(_o: CallOptionsT): void {
    _o.subgraph = this.subgraph();
  }
}

export class CallOptionsT {
  constructor(public subgraph: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return CallOptions.createCallOptions(builder, this.subgraph);
  }
}

export class PadOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): PadOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsPadOptions(bb: flatbuffers.ByteBuffer, obj?: PadOptions): PadOptions {
    return (obj || new PadOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsPadOptions(bb: flatbuffers.ByteBuffer, obj?: PadOptions): PadOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new PadOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startPadOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endPadOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createPadOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    PadOptions.startPadOptions(builder);
    return PadOptions.endPadOptions(builder);
  }

  unpack(): PadOptionsT {
    return new PadOptionsT();
  }


  unpackTo(_o: PadOptionsT): void {}
}

export class PadOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return PadOptions.createPadOptions(builder);
  }
}

export class PadV2Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): PadV2Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsPadV2Options(bb: flatbuffers.ByteBuffer, obj?: PadV2Options): PadV2Options {
    return (obj || new PadV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsPadV2Options(bb: flatbuffers.ByteBuffer, obj?: PadV2Options):
      PadV2Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new PadV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startPadV2Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endPadV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createPadV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    PadV2Options.startPadV2Options(builder);
    return PadV2Options.endPadV2Options(builder);
  }

  unpack(): PadV2OptionsT {
    return new PadV2OptionsT();
  }


  unpackTo(_o: PadV2OptionsT): void {}
}

export class PadV2OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return PadV2Options.createPadV2Options(builder);
  }
}

export class ReshapeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ReshapeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsReshapeOptions(bb: flatbuffers.ByteBuffer, obj?: ReshapeOptions): ReshapeOptions {
    return (obj || new ReshapeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsReshapeOptions(bb: flatbuffers.ByteBuffer, obj?: ReshapeOptions):
      ReshapeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ReshapeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  newShape(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  newShapeLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  newShapeArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startReshapeOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addNewShape(builder: flatbuffers.Builder, newShapeOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, newShapeOffset, 0);
  }

  static createNewShapeVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createNewShapeVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createNewShapeVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startNewShapeVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endReshapeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createReshapeOptions(builder: flatbuffers.Builder, newShapeOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    ReshapeOptions.startReshapeOptions(builder);
    ReshapeOptions.addNewShape(builder, newShapeOffset);
    return ReshapeOptions.endReshapeOptions(builder);
  }

  unpack(): ReshapeOptionsT {
    return new ReshapeOptionsT(
        this.bb!.createScalarList(this.newShape.bind(this), this.newShapeLength()));
  }


  unpackTo(_o: ReshapeOptionsT): void {
    _o.newShape = this.bb!.createScalarList(this.newShape.bind(this), this.newShapeLength());
  }
}

export class ReshapeOptionsT {
  constructor(public newShape: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const newShape = ReshapeOptions.createNewShapeVector(builder, this.newShape);

    return ReshapeOptions.createReshapeOptions(builder, newShape);
  }
}

export class SpaceToBatchNDOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SpaceToBatchNDOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSpaceToBatchNDOptions(bb: flatbuffers.ByteBuffer, obj?: SpaceToBatchNDOptions):
      SpaceToBatchNDOptions {
    return (obj || new SpaceToBatchNDOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSpaceToBatchNDOptions(
      bb: flatbuffers.ByteBuffer, obj?: SpaceToBatchNDOptions): SpaceToBatchNDOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SpaceToBatchNDOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSpaceToBatchNDOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSpaceToBatchNDOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSpaceToBatchNDOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SpaceToBatchNDOptions.startSpaceToBatchNDOptions(builder);
    return SpaceToBatchNDOptions.endSpaceToBatchNDOptions(builder);
  }

  unpack(): SpaceToBatchNDOptionsT {
    return new SpaceToBatchNDOptionsT();
  }


  unpackTo(_o: SpaceToBatchNDOptionsT): void {}
}

export class SpaceToBatchNDOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SpaceToBatchNDOptions.createSpaceToBatchNDOptions(builder);
  }
}

export class BatchToSpaceNDOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BatchToSpaceNDOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBatchToSpaceNDOptions(bb: flatbuffers.ByteBuffer, obj?: BatchToSpaceNDOptions):
      BatchToSpaceNDOptions {
    return (obj || new BatchToSpaceNDOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBatchToSpaceNDOptions(
      bb: flatbuffers.ByteBuffer, obj?: BatchToSpaceNDOptions): BatchToSpaceNDOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BatchToSpaceNDOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startBatchToSpaceNDOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endBatchToSpaceNDOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBatchToSpaceNDOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    BatchToSpaceNDOptions.startBatchToSpaceNDOptions(builder);
    return BatchToSpaceNDOptions.endBatchToSpaceNDOptions(builder);
  }

  unpack(): BatchToSpaceNDOptionsT {
    return new BatchToSpaceNDOptionsT();
  }


  unpackTo(_o: BatchToSpaceNDOptionsT): void {}
}

export class BatchToSpaceNDOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BatchToSpaceNDOptions.createBatchToSpaceNDOptions(builder);
  }
}

export class SkipGramOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SkipGramOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSkipGramOptions(bb: flatbuffers.ByteBuffer, obj?: SkipGramOptions):
      SkipGramOptions {
    return (obj || new SkipGramOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSkipGramOptions(bb: flatbuffers.ByteBuffer, obj?: SkipGramOptions):
      SkipGramOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SkipGramOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  ngramSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  maxSkipSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  includeAllNgrams(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startSkipGramOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addNgramSize(builder: flatbuffers.Builder, ngramSize: number) {
    builder.addFieldInt32(0, ngramSize, 0);
  }

  static addMaxSkipSize(builder: flatbuffers.Builder, maxSkipSize: number) {
    builder.addFieldInt32(1, maxSkipSize, 0);
  }

  static addIncludeAllNgrams(builder: flatbuffers.Builder, includeAllNgrams: boolean) {
    builder.addFieldInt8(2, +includeAllNgrams, +false);
  }

  static endSkipGramOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSkipGramOptions(
      builder: flatbuffers.Builder, ngramSize: number, maxSkipSize: number,
      includeAllNgrams: boolean): flatbuffers.Offset {
    SkipGramOptions.startSkipGramOptions(builder);
    SkipGramOptions.addNgramSize(builder, ngramSize);
    SkipGramOptions.addMaxSkipSize(builder, maxSkipSize);
    SkipGramOptions.addIncludeAllNgrams(builder, includeAllNgrams);
    return SkipGramOptions.endSkipGramOptions(builder);
  }

  unpack(): SkipGramOptionsT {
    return new SkipGramOptionsT(this.ngramSize(), this.maxSkipSize(), this.includeAllNgrams());
  }


  unpackTo(_o: SkipGramOptionsT): void {
    _o.ngramSize = this.ngramSize();
    _o.maxSkipSize = this.maxSkipSize();
    _o.includeAllNgrams = this.includeAllNgrams();
  }
}

export class SkipGramOptionsT {
  constructor(
      public ngramSize: number = 0, public maxSkipSize: number = 0,
      public includeAllNgrams: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SkipGramOptions.createSkipGramOptions(
        builder, this.ngramSize, this.maxSkipSize, this.includeAllNgrams);
  }
}

export class SpaceToDepthOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SpaceToDepthOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSpaceToDepthOptions(bb: flatbuffers.ByteBuffer, obj?: SpaceToDepthOptions):
      SpaceToDepthOptions {
    return (obj || new SpaceToDepthOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSpaceToDepthOptions(
      bb: flatbuffers.ByteBuffer, obj?: SpaceToDepthOptions): SpaceToDepthOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SpaceToDepthOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  blockSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startSpaceToDepthOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addBlockSize(builder: flatbuffers.Builder, blockSize: number) {
    builder.addFieldInt32(0, blockSize, 0);
  }

  static endSpaceToDepthOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSpaceToDepthOptions(builder: flatbuffers.Builder, blockSize: number):
      flatbuffers.Offset {
    SpaceToDepthOptions.startSpaceToDepthOptions(builder);
    SpaceToDepthOptions.addBlockSize(builder, blockSize);
    return SpaceToDepthOptions.endSpaceToDepthOptions(builder);
  }

  unpack(): SpaceToDepthOptionsT {
    return new SpaceToDepthOptionsT(this.blockSize());
  }


  unpackTo(_o: SpaceToDepthOptionsT): void {
    _o.blockSize = this.blockSize();
  }
}

export class SpaceToDepthOptionsT {
  constructor(public blockSize: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SpaceToDepthOptions.createSpaceToDepthOptions(builder, this.blockSize);
  }
}

export class DepthToSpaceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DepthToSpaceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDepthToSpaceOptions(bb: flatbuffers.ByteBuffer, obj?: DepthToSpaceOptions):
      DepthToSpaceOptions {
    return (obj || new DepthToSpaceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDepthToSpaceOptions(
      bb: flatbuffers.ByteBuffer, obj?: DepthToSpaceOptions): DepthToSpaceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DepthToSpaceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  blockSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startDepthToSpaceOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addBlockSize(builder: flatbuffers.Builder, blockSize: number) {
    builder.addFieldInt32(0, blockSize, 0);
  }

  static endDepthToSpaceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDepthToSpaceOptions(builder: flatbuffers.Builder, blockSize: number):
      flatbuffers.Offset {
    DepthToSpaceOptions.startDepthToSpaceOptions(builder);
    DepthToSpaceOptions.addBlockSize(builder, blockSize);
    return DepthToSpaceOptions.endDepthToSpaceOptions(builder);
  }

  unpack(): DepthToSpaceOptionsT {
    return new DepthToSpaceOptionsT(this.blockSize());
  }


  unpackTo(_o: DepthToSpaceOptionsT): void {
    _o.blockSize = this.blockSize();
  }
}

export class DepthToSpaceOptionsT {
  constructor(public blockSize: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DepthToSpaceOptions.createDepthToSpaceOptions(builder, this.blockSize);
  }
}

export class SubOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SubOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSubOptions(bb: flatbuffers.ByteBuffer, obj?: SubOptions): SubOptions {
    return (obj || new SubOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSubOptions(bb: flatbuffers.ByteBuffer, obj?: SubOptions): SubOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SubOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  potScaleInt16(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : true;
  }

  static startSubOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static addPotScaleInt16(builder: flatbuffers.Builder, potScaleInt16: boolean) {
    builder.addFieldInt8(1, +potScaleInt16, +true);
  }

  static endSubOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSubOptions(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType,
      potScaleInt16: boolean): flatbuffers.Offset {
    SubOptions.startSubOptions(builder);
    SubOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    SubOptions.addPotScaleInt16(builder, potScaleInt16);
    return SubOptions.endSubOptions(builder);
  }

  unpack(): SubOptionsT {
    return new SubOptionsT(this.fusedActivationFunction(), this.potScaleInt16());
  }


  unpackTo(_o: SubOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
    _o.potScaleInt16 = this.potScaleInt16();
  }
}

export class SubOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE,
      public potScaleInt16: boolean = true) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SubOptions.createSubOptions(builder, this.fusedActivationFunction, this.potScaleInt16);
  }
}

export class DivOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DivOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDivOptions(bb: flatbuffers.ByteBuffer, obj?: DivOptions): DivOptions {
    return (obj || new DivOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDivOptions(bb: flatbuffers.ByteBuffer, obj?: DivOptions): DivOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DivOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startDivOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(0, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endDivOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDivOptions(
      builder: flatbuffers.Builder,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    DivOptions.startDivOptions(builder);
    DivOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return DivOptions.endDivOptions(builder);
  }

  unpack(): DivOptionsT {
    return new DivOptionsT(this.fusedActivationFunction());
  }


  unpackTo(_o: DivOptionsT): void {
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class DivOptionsT {
  constructor(
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DivOptions.createDivOptions(builder, this.fusedActivationFunction);
  }
}

export class TopKV2Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): TopKV2Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTopKV2Options(bb: flatbuffers.ByteBuffer, obj?: TopKV2Options): TopKV2Options {
    return (obj || new TopKV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTopKV2Options(bb: flatbuffers.ByteBuffer, obj?: TopKV2Options):
      TopKV2Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new TopKV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startTopKV2Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endTopKV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createTopKV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    TopKV2Options.startTopKV2Options(builder);
    return TopKV2Options.endTopKV2Options(builder);
  }

  unpack(): TopKV2OptionsT {
    return new TopKV2OptionsT();
  }


  unpackTo(_o: TopKV2OptionsT): void {}
}

export class TopKV2OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return TopKV2Options.createTopKV2Options(builder);
  }
}

export class EmbeddingLookupSparseOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): EmbeddingLookupSparseOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsEmbeddingLookupSparseOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: EmbeddingLookupSparseOptions): EmbeddingLookupSparseOptions {
    return (obj || new EmbeddingLookupSparseOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsEmbeddingLookupSparseOptions(
      bb: flatbuffers.ByteBuffer,
      obj?: EmbeddingLookupSparseOptions): EmbeddingLookupSparseOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new EmbeddingLookupSparseOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  combiner(): CombinerType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : CombinerType.SUM;
  }

  static startEmbeddingLookupSparseOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addCombiner(builder: flatbuffers.Builder, combiner: CombinerType) {
    builder.addFieldInt8(0, combiner, CombinerType.SUM);
  }

  static endEmbeddingLookupSparseOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createEmbeddingLookupSparseOptions(builder: flatbuffers.Builder, combiner: CombinerType):
      flatbuffers.Offset {
    EmbeddingLookupSparseOptions.startEmbeddingLookupSparseOptions(builder);
    EmbeddingLookupSparseOptions.addCombiner(builder, combiner);
    return EmbeddingLookupSparseOptions.endEmbeddingLookupSparseOptions(builder);
  }

  unpack(): EmbeddingLookupSparseOptionsT {
    return new EmbeddingLookupSparseOptionsT(this.combiner());
  }


  unpackTo(_o: EmbeddingLookupSparseOptionsT): void {
    _o.combiner = this.combiner();
  }
}

export class EmbeddingLookupSparseOptionsT {
  constructor(public combiner: CombinerType = CombinerType.SUM) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return EmbeddingLookupSparseOptions.createEmbeddingLookupSparseOptions(builder, this.combiner);
  }
}

export class GatherOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): GatherOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsGatherOptions(bb: flatbuffers.ByteBuffer, obj?: GatherOptions): GatherOptions {
    return (obj || new GatherOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsGatherOptions(bb: flatbuffers.ByteBuffer, obj?: GatherOptions):
      GatherOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new GatherOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  batchDims(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startGatherOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(0, axis, 0);
  }

  static addBatchDims(builder: flatbuffers.Builder, batchDims: number) {
    builder.addFieldInt32(1, batchDims, 0);
  }

  static endGatherOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createGatherOptions(builder: flatbuffers.Builder, axis: number, batchDims: number):
      flatbuffers.Offset {
    GatherOptions.startGatherOptions(builder);
    GatherOptions.addAxis(builder, axis);
    GatherOptions.addBatchDims(builder, batchDims);
    return GatherOptions.endGatherOptions(builder);
  }

  unpack(): GatherOptionsT {
    return new GatherOptionsT(this.axis(), this.batchDims());
  }


  unpackTo(_o: GatherOptionsT): void {
    _o.axis = this.axis();
    _o.batchDims = this.batchDims();
  }
}

export class GatherOptionsT {
  constructor(public axis: number = 0, public batchDims: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return GatherOptions.createGatherOptions(builder, this.axis, this.batchDims);
  }
}

export class TransposeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): TransposeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTransposeOptions(bb: flatbuffers.ByteBuffer, obj?: TransposeOptions):
      TransposeOptions {
    return (obj || new TransposeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTransposeOptions(bb: flatbuffers.ByteBuffer, obj?: TransposeOptions):
      TransposeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new TransposeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startTransposeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endTransposeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createTransposeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    TransposeOptions.startTransposeOptions(builder);
    return TransposeOptions.endTransposeOptions(builder);
  }

  unpack(): TransposeOptionsT {
    return new TransposeOptionsT();
  }


  unpackTo(_o: TransposeOptionsT): void {}
}

export class TransposeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return TransposeOptions.createTransposeOptions(builder);
  }
}

export class ExpOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ExpOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsExpOptions(bb: flatbuffers.ByteBuffer, obj?: ExpOptions): ExpOptions {
    return (obj || new ExpOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsExpOptions(bb: flatbuffers.ByteBuffer, obj?: ExpOptions): ExpOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ExpOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startExpOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endExpOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createExpOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    ExpOptions.startExpOptions(builder);
    return ExpOptions.endExpOptions(builder);
  }

  unpack(): ExpOptionsT {
    return new ExpOptionsT();
  }


  unpackTo(_o: ExpOptionsT): void {}
}

export class ExpOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ExpOptions.createExpOptions(builder);
  }
}

export class CosOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CosOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCosOptions(bb: flatbuffers.ByteBuffer, obj?: CosOptions): CosOptions {
    return (obj || new CosOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCosOptions(bb: flatbuffers.ByteBuffer, obj?: CosOptions): CosOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CosOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startCosOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endCosOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCosOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    CosOptions.startCosOptions(builder);
    return CosOptions.endCosOptions(builder);
  }

  unpack(): CosOptionsT {
    return new CosOptionsT();
  }


  unpackTo(_o: CosOptionsT): void {}
}

export class CosOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return CosOptions.createCosOptions(builder);
  }
}

export class ReducerOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ReducerOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsReducerOptions(bb: flatbuffers.ByteBuffer, obj?: ReducerOptions): ReducerOptions {
    return (obj || new ReducerOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsReducerOptions(bb: flatbuffers.ByteBuffer, obj?: ReducerOptions):
      ReducerOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ReducerOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  keepDims(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startReducerOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addKeepDims(builder: flatbuffers.Builder, keepDims: boolean) {
    builder.addFieldInt8(0, +keepDims, +false);
  }

  static endReducerOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createReducerOptions(builder: flatbuffers.Builder, keepDims: boolean): flatbuffers.Offset {
    ReducerOptions.startReducerOptions(builder);
    ReducerOptions.addKeepDims(builder, keepDims);
    return ReducerOptions.endReducerOptions(builder);
  }

  unpack(): ReducerOptionsT {
    return new ReducerOptionsT(this.keepDims());
  }


  unpackTo(_o: ReducerOptionsT): void {
    _o.keepDims = this.keepDims();
  }
}

export class ReducerOptionsT {
  constructor(public keepDims: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ReducerOptions.createReducerOptions(builder, this.keepDims);
  }
}

export class SqueezeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SqueezeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSqueezeOptions(bb: flatbuffers.ByteBuffer, obj?: SqueezeOptions): SqueezeOptions {
    return (obj || new SqueezeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSqueezeOptions(bb: flatbuffers.ByteBuffer, obj?: SqueezeOptions):
      SqueezeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SqueezeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  squeezeDims(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  squeezeDimsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  squeezeDimsArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startSqueezeOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addSqueezeDims(builder: flatbuffers.Builder, squeezeDimsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, squeezeDimsOffset, 0);
  }

  static createSqueezeDimsVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createSqueezeDimsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createSqueezeDimsVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startSqueezeDimsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endSqueezeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSqueezeOptions(builder: flatbuffers.Builder, squeezeDimsOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    SqueezeOptions.startSqueezeOptions(builder);
    SqueezeOptions.addSqueezeDims(builder, squeezeDimsOffset);
    return SqueezeOptions.endSqueezeOptions(builder);
  }

  unpack(): SqueezeOptionsT {
    return new SqueezeOptionsT(
        this.bb!.createScalarList(this.squeezeDims.bind(this), this.squeezeDimsLength()));
  }


  unpackTo(_o: SqueezeOptionsT): void {
    _o.squeezeDims =
        this.bb!.createScalarList(this.squeezeDims.bind(this), this.squeezeDimsLength());
  }
}

export class SqueezeOptionsT {
  constructor(public squeezeDims: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const squeezeDims = SqueezeOptions.createSqueezeDimsVector(builder, this.squeezeDims);

    return SqueezeOptions.createSqueezeOptions(builder, squeezeDims);
  }
}

export class SplitOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SplitOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSplitOptions(bb: flatbuffers.ByteBuffer, obj?: SplitOptions): SplitOptions {
    return (obj || new SplitOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSplitOptions(bb: flatbuffers.ByteBuffer, obj?: SplitOptions):
      SplitOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SplitOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  numSplits(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startSplitOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addNumSplits(builder: flatbuffers.Builder, numSplits: number) {
    builder.addFieldInt32(0, numSplits, 0);
  }

  static endSplitOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSplitOptions(builder: flatbuffers.Builder, numSplits: number): flatbuffers.Offset {
    SplitOptions.startSplitOptions(builder);
    SplitOptions.addNumSplits(builder, numSplits);
    return SplitOptions.endSplitOptions(builder);
  }

  unpack(): SplitOptionsT {
    return new SplitOptionsT(this.numSplits());
  }


  unpackTo(_o: SplitOptionsT): void {
    _o.numSplits = this.numSplits();
  }
}

export class SplitOptionsT {
  constructor(public numSplits: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SplitOptions.createSplitOptions(builder, this.numSplits);
  }
}

export class SplitVOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SplitVOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSplitVOptions(bb: flatbuffers.ByteBuffer, obj?: SplitVOptions): SplitVOptions {
    return (obj || new SplitVOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSplitVOptions(bb: flatbuffers.ByteBuffer, obj?: SplitVOptions):
      SplitVOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SplitVOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  numSplits(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startSplitVOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addNumSplits(builder: flatbuffers.Builder, numSplits: number) {
    builder.addFieldInt32(0, numSplits, 0);
  }

  static endSplitVOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSplitVOptions(builder: flatbuffers.Builder, numSplits: number): flatbuffers.Offset {
    SplitVOptions.startSplitVOptions(builder);
    SplitVOptions.addNumSplits(builder, numSplits);
    return SplitVOptions.endSplitVOptions(builder);
  }

  unpack(): SplitVOptionsT {
    return new SplitVOptionsT(this.numSplits());
  }


  unpackTo(_o: SplitVOptionsT): void {
    _o.numSplits = this.numSplits();
  }
}

export class SplitVOptionsT {
  constructor(public numSplits: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SplitVOptions.createSplitVOptions(builder, this.numSplits);
  }
}

export class StridedSliceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): StridedSliceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsStridedSliceOptions(bb: flatbuffers.ByteBuffer, obj?: StridedSliceOptions):
      StridedSliceOptions {
    return (obj || new StridedSliceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsStridedSliceOptions(
      bb: flatbuffers.ByteBuffer, obj?: StridedSliceOptions): StridedSliceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new StridedSliceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  beginMask(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  endMask(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  ellipsisMask(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  newAxisMask(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  shrinkAxisMask(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startStridedSliceOptions(builder: flatbuffers.Builder) {
    builder.startObject(5);
  }

  static addBeginMask(builder: flatbuffers.Builder, beginMask: number) {
    builder.addFieldInt32(0, beginMask, 0);
  }

  static addEndMask(builder: flatbuffers.Builder, endMask: number) {
    builder.addFieldInt32(1, endMask, 0);
  }

  static addEllipsisMask(builder: flatbuffers.Builder, ellipsisMask: number) {
    builder.addFieldInt32(2, ellipsisMask, 0);
  }

  static addNewAxisMask(builder: flatbuffers.Builder, newAxisMask: number) {
    builder.addFieldInt32(3, newAxisMask, 0);
  }

  static addShrinkAxisMask(builder: flatbuffers.Builder, shrinkAxisMask: number) {
    builder.addFieldInt32(4, shrinkAxisMask, 0);
  }

  static endStridedSliceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createStridedSliceOptions(
      builder: flatbuffers.Builder, beginMask: number, endMask: number, ellipsisMask: number,
      newAxisMask: number, shrinkAxisMask: number): flatbuffers.Offset {
    StridedSliceOptions.startStridedSliceOptions(builder);
    StridedSliceOptions.addBeginMask(builder, beginMask);
    StridedSliceOptions.addEndMask(builder, endMask);
    StridedSliceOptions.addEllipsisMask(builder, ellipsisMask);
    StridedSliceOptions.addNewAxisMask(builder, newAxisMask);
    StridedSliceOptions.addShrinkAxisMask(builder, shrinkAxisMask);
    return StridedSliceOptions.endStridedSliceOptions(builder);
  }

  unpack(): StridedSliceOptionsT {
    return new StridedSliceOptionsT(
        this.beginMask(), this.endMask(), this.ellipsisMask(), this.newAxisMask(),
        this.shrinkAxisMask());
  }


  unpackTo(_o: StridedSliceOptionsT): void {
    _o.beginMask = this.beginMask();
    _o.endMask = this.endMask();
    _o.ellipsisMask = this.ellipsisMask();
    _o.newAxisMask = this.newAxisMask();
    _o.shrinkAxisMask = this.shrinkAxisMask();
  }
}

export class StridedSliceOptionsT {
  constructor(
      public beginMask: number = 0, public endMask: number = 0, public ellipsisMask: number = 0,
      public newAxisMask: number = 0, public shrinkAxisMask: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return StridedSliceOptions.createStridedSliceOptions(
        builder, this.beginMask, this.endMask, this.ellipsisMask, this.newAxisMask,
        this.shrinkAxisMask);
  }
}

export class LogSoftmaxOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LogSoftmaxOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLogSoftmaxOptions(bb: flatbuffers.ByteBuffer, obj?: LogSoftmaxOptions):
      LogSoftmaxOptions {
    return (obj || new LogSoftmaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLogSoftmaxOptions(
      bb: flatbuffers.ByteBuffer, obj?: LogSoftmaxOptions): LogSoftmaxOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LogSoftmaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLogSoftmaxOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLogSoftmaxOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLogSoftmaxOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LogSoftmaxOptions.startLogSoftmaxOptions(builder);
    return LogSoftmaxOptions.endLogSoftmaxOptions(builder);
  }

  unpack(): LogSoftmaxOptionsT {
    return new LogSoftmaxOptionsT();
  }


  unpackTo(_o: LogSoftmaxOptionsT): void {}
}

export class LogSoftmaxOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LogSoftmaxOptions.createLogSoftmaxOptions(builder);
  }
}

export class CastOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CastOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCastOptions(bb: flatbuffers.ByteBuffer, obj?: CastOptions): CastOptions {
    return (obj || new CastOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCastOptions(bb: flatbuffers.ByteBuffer, obj?: CastOptions):
      CastOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CastOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  inDataType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  outDataType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  static startCastOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addInDataType(builder: flatbuffers.Builder, inDataType: TensorType) {
    builder.addFieldInt8(0, inDataType, TensorType.FLOAT32);
  }

  static addOutDataType(builder: flatbuffers.Builder, outDataType: TensorType) {
    builder.addFieldInt8(1, outDataType, TensorType.FLOAT32);
  }

  static endCastOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCastOptions(
      builder: flatbuffers.Builder, inDataType: TensorType,
      outDataType: TensorType): flatbuffers.Offset {
    CastOptions.startCastOptions(builder);
    CastOptions.addInDataType(builder, inDataType);
    CastOptions.addOutDataType(builder, outDataType);
    return CastOptions.endCastOptions(builder);
  }

  unpack(): CastOptionsT {
    return new CastOptionsT(this.inDataType(), this.outDataType());
  }


  unpackTo(_o: CastOptionsT): void {
    _o.inDataType = this.inDataType();
    _o.outDataType = this.outDataType();
  }
}

export class CastOptionsT {
  constructor(
      public inDataType: TensorType = TensorType.FLOAT32,
      public outDataType: TensorType = TensorType.FLOAT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return CastOptions.createCastOptions(builder, this.inDataType, this.outDataType);
  }
}

export class DequantizeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DequantizeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDequantizeOptions(bb: flatbuffers.ByteBuffer, obj?: DequantizeOptions):
      DequantizeOptions {
    return (obj || new DequantizeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDequantizeOptions(
      bb: flatbuffers.ByteBuffer, obj?: DequantizeOptions): DequantizeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DequantizeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startDequantizeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endDequantizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDequantizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    DequantizeOptions.startDequantizeOptions(builder);
    return DequantizeOptions.endDequantizeOptions(builder);
  }

  unpack(): DequantizeOptionsT {
    return new DequantizeOptionsT();
  }


  unpackTo(_o: DequantizeOptionsT): void {}
}

export class DequantizeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DequantizeOptions.createDequantizeOptions(builder);
  }
}

export class MaximumMinimumOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): MaximumMinimumOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMaximumMinimumOptions(bb: flatbuffers.ByteBuffer, obj?: MaximumMinimumOptions):
      MaximumMinimumOptions {
    return (obj || new MaximumMinimumOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMaximumMinimumOptions(
      bb: flatbuffers.ByteBuffer, obj?: MaximumMinimumOptions): MaximumMinimumOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new MaximumMinimumOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startMaximumMinimumOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endMaximumMinimumOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMaximumMinimumOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    MaximumMinimumOptions.startMaximumMinimumOptions(builder);
    return MaximumMinimumOptions.endMaximumMinimumOptions(builder);
  }

  unpack(): MaximumMinimumOptionsT {
    return new MaximumMinimumOptionsT();
  }


  unpackTo(_o: MaximumMinimumOptionsT): void {}
}

export class MaximumMinimumOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return MaximumMinimumOptions.createMaximumMinimumOptions(builder);
  }
}

export class TileOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): TileOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTileOptions(bb: flatbuffers.ByteBuffer, obj?: TileOptions): TileOptions {
    return (obj || new TileOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTileOptions(bb: flatbuffers.ByteBuffer, obj?: TileOptions):
      TileOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new TileOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startTileOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endTileOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createTileOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    TileOptions.startTileOptions(builder);
    return TileOptions.endTileOptions(builder);
  }

  unpack(): TileOptionsT {
    return new TileOptionsT();
  }


  unpackTo(_o: TileOptionsT): void {}
}

export class TileOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return TileOptions.createTileOptions(builder);
  }
}

export class ArgMaxOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ArgMaxOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsArgMaxOptions(bb: flatbuffers.ByteBuffer, obj?: ArgMaxOptions): ArgMaxOptions {
    return (obj || new ArgMaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsArgMaxOptions(bb: flatbuffers.ByteBuffer, obj?: ArgMaxOptions):
      ArgMaxOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ArgMaxOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  outputType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  static startArgMaxOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addOutputType(builder: flatbuffers.Builder, outputType: TensorType) {
    builder.addFieldInt8(0, outputType, TensorType.FLOAT32);
  }

  static endArgMaxOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createArgMaxOptions(builder: flatbuffers.Builder, outputType: TensorType):
      flatbuffers.Offset {
    ArgMaxOptions.startArgMaxOptions(builder);
    ArgMaxOptions.addOutputType(builder, outputType);
    return ArgMaxOptions.endArgMaxOptions(builder);
  }

  unpack(): ArgMaxOptionsT {
    return new ArgMaxOptionsT(this.outputType());
  }


  unpackTo(_o: ArgMaxOptionsT): void {
    _o.outputType = this.outputType();
  }
}

export class ArgMaxOptionsT {
  constructor(public outputType: TensorType = TensorType.FLOAT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ArgMaxOptions.createArgMaxOptions(builder, this.outputType);
  }
}

export class ArgMinOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ArgMinOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsArgMinOptions(bb: flatbuffers.ByteBuffer, obj?: ArgMinOptions): ArgMinOptions {
    return (obj || new ArgMinOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsArgMinOptions(bb: flatbuffers.ByteBuffer, obj?: ArgMinOptions):
      ArgMinOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ArgMinOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  outputType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  static startArgMinOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addOutputType(builder: flatbuffers.Builder, outputType: TensorType) {
    builder.addFieldInt8(0, outputType, TensorType.FLOAT32);
  }

  static endArgMinOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createArgMinOptions(builder: flatbuffers.Builder, outputType: TensorType):
      flatbuffers.Offset {
    ArgMinOptions.startArgMinOptions(builder);
    ArgMinOptions.addOutputType(builder, outputType);
    return ArgMinOptions.endArgMinOptions(builder);
  }

  unpack(): ArgMinOptionsT {
    return new ArgMinOptionsT(this.outputType());
  }


  unpackTo(_o: ArgMinOptionsT): void {
    _o.outputType = this.outputType();
  }
}

export class ArgMinOptionsT {
  constructor(public outputType: TensorType = TensorType.FLOAT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ArgMinOptions.createArgMinOptions(builder, this.outputType);
  }
}

export class GreaterOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): GreaterOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsGreaterOptions(bb: flatbuffers.ByteBuffer, obj?: GreaterOptions): GreaterOptions {
    return (obj || new GreaterOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsGreaterOptions(bb: flatbuffers.ByteBuffer, obj?: GreaterOptions):
      GreaterOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new GreaterOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startGreaterOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endGreaterOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createGreaterOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    GreaterOptions.startGreaterOptions(builder);
    return GreaterOptions.endGreaterOptions(builder);
  }

  unpack(): GreaterOptionsT {
    return new GreaterOptionsT();
  }


  unpackTo(_o: GreaterOptionsT): void {}
}

export class GreaterOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return GreaterOptions.createGreaterOptions(builder);
  }
}

export class GreaterEqualOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): GreaterEqualOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsGreaterEqualOptions(bb: flatbuffers.ByteBuffer, obj?: GreaterEqualOptions):
      GreaterEqualOptions {
    return (obj || new GreaterEqualOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsGreaterEqualOptions(
      bb: flatbuffers.ByteBuffer, obj?: GreaterEqualOptions): GreaterEqualOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new GreaterEqualOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startGreaterEqualOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endGreaterEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createGreaterEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    GreaterEqualOptions.startGreaterEqualOptions(builder);
    return GreaterEqualOptions.endGreaterEqualOptions(builder);
  }

  unpack(): GreaterEqualOptionsT {
    return new GreaterEqualOptionsT();
  }


  unpackTo(_o: GreaterEqualOptionsT): void {}
}

export class GreaterEqualOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return GreaterEqualOptions.createGreaterEqualOptions(builder);
  }
}

export class LessOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LessOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLessOptions(bb: flatbuffers.ByteBuffer, obj?: LessOptions): LessOptions {
    return (obj || new LessOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLessOptions(bb: flatbuffers.ByteBuffer, obj?: LessOptions):
      LessOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LessOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLessOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLessOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLessOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LessOptions.startLessOptions(builder);
    return LessOptions.endLessOptions(builder);
  }

  unpack(): LessOptionsT {
    return new LessOptionsT();
  }


  unpackTo(_o: LessOptionsT): void {}
}

export class LessOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LessOptions.createLessOptions(builder);
  }
}

export class LessEqualOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LessEqualOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLessEqualOptions(bb: flatbuffers.ByteBuffer, obj?: LessEqualOptions):
      LessEqualOptions {
    return (obj || new LessEqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLessEqualOptions(bb: flatbuffers.ByteBuffer, obj?: LessEqualOptions):
      LessEqualOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LessEqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLessEqualOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLessEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLessEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LessEqualOptions.startLessEqualOptions(builder);
    return LessEqualOptions.endLessEqualOptions(builder);
  }

  unpack(): LessEqualOptionsT {
    return new LessEqualOptionsT();
  }


  unpackTo(_o: LessEqualOptionsT): void {}
}

export class LessEqualOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LessEqualOptions.createLessEqualOptions(builder);
  }
}

export class NegOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): NegOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsNegOptions(bb: flatbuffers.ByteBuffer, obj?: NegOptions): NegOptions {
    return (obj || new NegOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsNegOptions(bb: flatbuffers.ByteBuffer, obj?: NegOptions): NegOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new NegOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startNegOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endNegOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createNegOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    NegOptions.startNegOptions(builder);
    return NegOptions.endNegOptions(builder);
  }

  unpack(): NegOptionsT {
    return new NegOptionsT();
  }


  unpackTo(_o: NegOptionsT): void {}
}

export class NegOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return NegOptions.createNegOptions(builder);
  }
}

export class SelectOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SelectOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSelectOptions(bb: flatbuffers.ByteBuffer, obj?: SelectOptions): SelectOptions {
    return (obj || new SelectOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSelectOptions(bb: flatbuffers.ByteBuffer, obj?: SelectOptions):
      SelectOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SelectOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSelectOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSelectOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSelectOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SelectOptions.startSelectOptions(builder);
    return SelectOptions.endSelectOptions(builder);
  }

  unpack(): SelectOptionsT {
    return new SelectOptionsT();
  }


  unpackTo(_o: SelectOptionsT): void {}
}

export class SelectOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SelectOptions.createSelectOptions(builder);
  }
}

export class SliceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SliceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSliceOptions(bb: flatbuffers.ByteBuffer, obj?: SliceOptions): SliceOptions {
    return (obj || new SliceOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSliceOptions(bb: flatbuffers.ByteBuffer, obj?: SliceOptions):
      SliceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SliceOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSliceOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSliceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSliceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SliceOptions.startSliceOptions(builder);
    return SliceOptions.endSliceOptions(builder);
  }

  unpack(): SliceOptionsT {
    return new SliceOptionsT();
  }


  unpackTo(_o: SliceOptionsT): void {}
}

export class SliceOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SliceOptions.createSliceOptions(builder);
  }
}

export class TransposeConvOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): TransposeConvOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTransposeConvOptions(bb: flatbuffers.ByteBuffer, obj?: TransposeConvOptions):
      TransposeConvOptions {
    return (obj || new TransposeConvOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTransposeConvOptions(
      bb: flatbuffers.ByteBuffer, obj?: TransposeConvOptions): TransposeConvOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new TransposeConvOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  padding(): Padding {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : Padding.SAME;
  }

  strideW(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  strideH(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startTransposeConvOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addPadding(builder: flatbuffers.Builder, padding: Padding) {
    builder.addFieldInt8(0, padding, Padding.SAME);
  }

  static addStrideW(builder: flatbuffers.Builder, strideW: number) {
    builder.addFieldInt32(1, strideW, 0);
  }

  static addStrideH(builder: flatbuffers.Builder, strideH: number) {
    builder.addFieldInt32(2, strideH, 0);
  }

  static endTransposeConvOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createTransposeConvOptions(
      builder: flatbuffers.Builder, padding: Padding, strideW: number,
      strideH: number): flatbuffers.Offset {
    TransposeConvOptions.startTransposeConvOptions(builder);
    TransposeConvOptions.addPadding(builder, padding);
    TransposeConvOptions.addStrideW(builder, strideW);
    TransposeConvOptions.addStrideH(builder, strideH);
    return TransposeConvOptions.endTransposeConvOptions(builder);
  }

  unpack(): TransposeConvOptionsT {
    return new TransposeConvOptionsT(this.padding(), this.strideW(), this.strideH());
  }


  unpackTo(_o: TransposeConvOptionsT): void {
    _o.padding = this.padding();
    _o.strideW = this.strideW();
    _o.strideH = this.strideH();
  }
}

export class TransposeConvOptionsT {
  constructor(
      public padding: Padding = Padding.SAME, public strideW: number = 0,
      public strideH: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return TransposeConvOptions.createTransposeConvOptions(
        builder, this.padding, this.strideW, this.strideH);
  }
}

export class ExpandDimsOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ExpandDimsOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsExpandDimsOptions(bb: flatbuffers.ByteBuffer, obj?: ExpandDimsOptions):
      ExpandDimsOptions {
    return (obj || new ExpandDimsOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsExpandDimsOptions(
      bb: flatbuffers.ByteBuffer, obj?: ExpandDimsOptions): ExpandDimsOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ExpandDimsOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startExpandDimsOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endExpandDimsOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createExpandDimsOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    ExpandDimsOptions.startExpandDimsOptions(builder);
    return ExpandDimsOptions.endExpandDimsOptions(builder);
  }

  unpack(): ExpandDimsOptionsT {
    return new ExpandDimsOptionsT();
  }


  unpackTo(_o: ExpandDimsOptionsT): void {}
}

export class ExpandDimsOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ExpandDimsOptions.createExpandDimsOptions(builder);
  }
}

export class SparseToDenseOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SparseToDenseOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSparseToDenseOptions(bb: flatbuffers.ByteBuffer, obj?: SparseToDenseOptions):
      SparseToDenseOptions {
    return (obj || new SparseToDenseOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSparseToDenseOptions(
      bb: flatbuffers.ByteBuffer, obj?: SparseToDenseOptions): SparseToDenseOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SparseToDenseOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  validateIndices(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startSparseToDenseOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addValidateIndices(builder: flatbuffers.Builder, validateIndices: boolean) {
    builder.addFieldInt8(0, +validateIndices, +false);
  }

  static endSparseToDenseOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSparseToDenseOptions(builder: flatbuffers.Builder, validateIndices: boolean):
      flatbuffers.Offset {
    SparseToDenseOptions.startSparseToDenseOptions(builder);
    SparseToDenseOptions.addValidateIndices(builder, validateIndices);
    return SparseToDenseOptions.endSparseToDenseOptions(builder);
  }

  unpack(): SparseToDenseOptionsT {
    return new SparseToDenseOptionsT(this.validateIndices());
  }


  unpackTo(_o: SparseToDenseOptionsT): void {
    _o.validateIndices = this.validateIndices();
  }
}

export class SparseToDenseOptionsT {
  constructor(public validateIndices: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SparseToDenseOptions.createSparseToDenseOptions(builder, this.validateIndices);
  }
}

export class EqualOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): EqualOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsEqualOptions(bb: flatbuffers.ByteBuffer, obj?: EqualOptions): EqualOptions {
    return (obj || new EqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsEqualOptions(bb: flatbuffers.ByteBuffer, obj?: EqualOptions):
      EqualOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new EqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startEqualOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    EqualOptions.startEqualOptions(builder);
    return EqualOptions.endEqualOptions(builder);
  }

  unpack(): EqualOptionsT {
    return new EqualOptionsT();
  }


  unpackTo(_o: EqualOptionsT): void {}
}

export class EqualOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return EqualOptions.createEqualOptions(builder);
  }
}

export class NotEqualOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): NotEqualOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsNotEqualOptions(bb: flatbuffers.ByteBuffer, obj?: NotEqualOptions):
      NotEqualOptions {
    return (obj || new NotEqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsNotEqualOptions(bb: flatbuffers.ByteBuffer, obj?: NotEqualOptions):
      NotEqualOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new NotEqualOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startNotEqualOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endNotEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createNotEqualOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    NotEqualOptions.startNotEqualOptions(builder);
    return NotEqualOptions.endNotEqualOptions(builder);
  }

  unpack(): NotEqualOptionsT {
    return new NotEqualOptionsT();
  }


  unpackTo(_o: NotEqualOptionsT): void {}
}

export class NotEqualOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return NotEqualOptions.createNotEqualOptions(builder);
  }
}

export class ShapeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ShapeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsShapeOptions(bb: flatbuffers.ByteBuffer, obj?: ShapeOptions): ShapeOptions {
    return (obj || new ShapeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsShapeOptions(bb: flatbuffers.ByteBuffer, obj?: ShapeOptions):
      ShapeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ShapeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  outType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  static startShapeOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addOutType(builder: flatbuffers.Builder, outType: TensorType) {
    builder.addFieldInt8(0, outType, TensorType.FLOAT32);
  }

  static endShapeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createShapeOptions(builder: flatbuffers.Builder, outType: TensorType): flatbuffers.Offset {
    ShapeOptions.startShapeOptions(builder);
    ShapeOptions.addOutType(builder, outType);
    return ShapeOptions.endShapeOptions(builder);
  }

  unpack(): ShapeOptionsT {
    return new ShapeOptionsT(this.outType());
  }


  unpackTo(_o: ShapeOptionsT): void {
    _o.outType = this.outType();
  }
}

export class ShapeOptionsT {
  constructor(public outType: TensorType = TensorType.FLOAT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ShapeOptions.createShapeOptions(builder, this.outType);
  }
}

export class RankOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): RankOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsRankOptions(bb: flatbuffers.ByteBuffer, obj?: RankOptions): RankOptions {
    return (obj || new RankOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsRankOptions(bb: flatbuffers.ByteBuffer, obj?: RankOptions):
      RankOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new RankOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startRankOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endRankOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createRankOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    RankOptions.startRankOptions(builder);
    return RankOptions.endRankOptions(builder);
  }

  unpack(): RankOptionsT {
    return new RankOptionsT();
  }


  unpackTo(_o: RankOptionsT): void {}
}

export class RankOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return RankOptions.createRankOptions(builder);
  }
}

export class PowOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): PowOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsPowOptions(bb: flatbuffers.ByteBuffer, obj?: PowOptions): PowOptions {
    return (obj || new PowOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsPowOptions(bb: flatbuffers.ByteBuffer, obj?: PowOptions): PowOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new PowOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startPowOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endPowOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createPowOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    PowOptions.startPowOptions(builder);
    return PowOptions.endPowOptions(builder);
  }

  unpack(): PowOptionsT {
    return new PowOptionsT();
  }


  unpackTo(_o: PowOptionsT): void {}
}

export class PowOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return PowOptions.createPowOptions(builder);
  }
}

export class FakeQuantOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): FakeQuantOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsFakeQuantOptions(bb: flatbuffers.ByteBuffer, obj?: FakeQuantOptions):
      FakeQuantOptions {
    return (obj || new FakeQuantOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFakeQuantOptions(bb: flatbuffers.ByteBuffer, obj?: FakeQuantOptions):
      FakeQuantOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new FakeQuantOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  min(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  max(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  numBits(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  narrowRange(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startFakeQuantOptions(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addMin(builder: flatbuffers.Builder, min: number) {
    builder.addFieldFloat32(0, min, 0.0);
  }

  static addMax(builder: flatbuffers.Builder, max: number) {
    builder.addFieldFloat32(1, max, 0.0);
  }

  static addNumBits(builder: flatbuffers.Builder, numBits: number) {
    builder.addFieldInt32(2, numBits, 0);
  }

  static addNarrowRange(builder: flatbuffers.Builder, narrowRange: boolean) {
    builder.addFieldInt8(3, +narrowRange, +false);
  }

  static endFakeQuantOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createFakeQuantOptions(
      builder: flatbuffers.Builder, min: number, max: number, numBits: number,
      narrowRange: boolean): flatbuffers.Offset {
    FakeQuantOptions.startFakeQuantOptions(builder);
    FakeQuantOptions.addMin(builder, min);
    FakeQuantOptions.addMax(builder, max);
    FakeQuantOptions.addNumBits(builder, numBits);
    FakeQuantOptions.addNarrowRange(builder, narrowRange);
    return FakeQuantOptions.endFakeQuantOptions(builder);
  }

  unpack(): FakeQuantOptionsT {
    return new FakeQuantOptionsT(this.min(), this.max(), this.numBits(), this.narrowRange());
  }


  unpackTo(_o: FakeQuantOptionsT): void {
    _o.min = this.min();
    _o.max = this.max();
    _o.numBits = this.numBits();
    _o.narrowRange = this.narrowRange();
  }
}

export class FakeQuantOptionsT {
  constructor(
      public min: number = 0.0, public max: number = 0.0, public numBits: number = 0,
      public narrowRange: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return FakeQuantOptions.createFakeQuantOptions(
        builder, this.min, this.max, this.numBits, this.narrowRange);
  }
}

export class PackOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): PackOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsPackOptions(bb: flatbuffers.ByteBuffer, obj?: PackOptions): PackOptions {
    return (obj || new PackOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsPackOptions(bb: flatbuffers.ByteBuffer, obj?: PackOptions):
      PackOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new PackOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  valuesCount(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startPackOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addValuesCount(builder: flatbuffers.Builder, valuesCount: number) {
    builder.addFieldInt32(0, valuesCount, 0);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(1, axis, 0);
  }

  static endPackOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createPackOptions(builder: flatbuffers.Builder, valuesCount: number, axis: number):
      flatbuffers.Offset {
    PackOptions.startPackOptions(builder);
    PackOptions.addValuesCount(builder, valuesCount);
    PackOptions.addAxis(builder, axis);
    return PackOptions.endPackOptions(builder);
  }

  unpack(): PackOptionsT {
    return new PackOptionsT(this.valuesCount(), this.axis());
  }


  unpackTo(_o: PackOptionsT): void {
    _o.valuesCount = this.valuesCount();
    _o.axis = this.axis();
  }
}

export class PackOptionsT {
  constructor(public valuesCount: number = 0, public axis: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return PackOptions.createPackOptions(builder, this.valuesCount, this.axis);
  }
}

export class LogicalOrOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LogicalOrOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLogicalOrOptions(bb: flatbuffers.ByteBuffer, obj?: LogicalOrOptions):
      LogicalOrOptions {
    return (obj || new LogicalOrOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLogicalOrOptions(bb: flatbuffers.ByteBuffer, obj?: LogicalOrOptions):
      LogicalOrOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LogicalOrOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLogicalOrOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLogicalOrOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLogicalOrOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LogicalOrOptions.startLogicalOrOptions(builder);
    return LogicalOrOptions.endLogicalOrOptions(builder);
  }

  unpack(): LogicalOrOptionsT {
    return new LogicalOrOptionsT();
  }


  unpackTo(_o: LogicalOrOptionsT): void {}
}

export class LogicalOrOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LogicalOrOptions.createLogicalOrOptions(builder);
  }
}

export class OneHotOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): OneHotOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsOneHotOptions(bb: flatbuffers.ByteBuffer, obj?: OneHotOptions): OneHotOptions {
    return (obj || new OneHotOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsOneHotOptions(bb: flatbuffers.ByteBuffer, obj?: OneHotOptions):
      OneHotOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new OneHotOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startOneHotOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(0, axis, 0);
  }

  static endOneHotOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createOneHotOptions(builder: flatbuffers.Builder, axis: number): flatbuffers.Offset {
    OneHotOptions.startOneHotOptions(builder);
    OneHotOptions.addAxis(builder, axis);
    return OneHotOptions.endOneHotOptions(builder);
  }

  unpack(): OneHotOptionsT {
    return new OneHotOptionsT(this.axis());
  }


  unpackTo(_o: OneHotOptionsT): void {
    _o.axis = this.axis();
  }
}

export class OneHotOptionsT {
  constructor(public axis: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return OneHotOptions.createOneHotOptions(builder, this.axis);
  }
}

export class AbsOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): AbsOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsAbsOptions(bb: flatbuffers.ByteBuffer, obj?: AbsOptions): AbsOptions {
    return (obj || new AbsOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsAbsOptions(bb: flatbuffers.ByteBuffer, obj?: AbsOptions): AbsOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new AbsOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startAbsOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endAbsOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createAbsOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    AbsOptions.startAbsOptions(builder);
    return AbsOptions.endAbsOptions(builder);
  }

  unpack(): AbsOptionsT {
    return new AbsOptionsT();
  }


  unpackTo(_o: AbsOptionsT): void {}
}

export class AbsOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return AbsOptions.createAbsOptions(builder);
  }
}

export class HardSwishOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): HardSwishOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsHardSwishOptions(bb: flatbuffers.ByteBuffer, obj?: HardSwishOptions):
      HardSwishOptions {
    return (obj || new HardSwishOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsHardSwishOptions(bb: flatbuffers.ByteBuffer, obj?: HardSwishOptions):
      HardSwishOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new HardSwishOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startHardSwishOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endHardSwishOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createHardSwishOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    HardSwishOptions.startHardSwishOptions(builder);
    return HardSwishOptions.endHardSwishOptions(builder);
  }

  unpack(): HardSwishOptionsT {
    return new HardSwishOptionsT();
  }


  unpackTo(_o: HardSwishOptionsT): void {}
}

export class HardSwishOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return HardSwishOptions.createHardSwishOptions(builder);
  }
}

export class LogicalAndOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LogicalAndOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLogicalAndOptions(bb: flatbuffers.ByteBuffer, obj?: LogicalAndOptions):
      LogicalAndOptions {
    return (obj || new LogicalAndOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLogicalAndOptions(
      bb: flatbuffers.ByteBuffer, obj?: LogicalAndOptions): LogicalAndOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LogicalAndOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLogicalAndOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLogicalAndOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLogicalAndOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LogicalAndOptions.startLogicalAndOptions(builder);
    return LogicalAndOptions.endLogicalAndOptions(builder);
  }

  unpack(): LogicalAndOptionsT {
    return new LogicalAndOptionsT();
  }


  unpackTo(_o: LogicalAndOptionsT): void {}
}

export class LogicalAndOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LogicalAndOptions.createLogicalAndOptions(builder);
  }
}

export class LogicalNotOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LogicalNotOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLogicalNotOptions(bb: flatbuffers.ByteBuffer, obj?: LogicalNotOptions):
      LogicalNotOptions {
    return (obj || new LogicalNotOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLogicalNotOptions(
      bb: flatbuffers.ByteBuffer, obj?: LogicalNotOptions): LogicalNotOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LogicalNotOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startLogicalNotOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endLogicalNotOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLogicalNotOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    LogicalNotOptions.startLogicalNotOptions(builder);
    return LogicalNotOptions.endLogicalNotOptions(builder);
  }

  unpack(): LogicalNotOptionsT {
    return new LogicalNotOptionsT();
  }


  unpackTo(_o: LogicalNotOptionsT): void {}
}

export class LogicalNotOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LogicalNotOptions.createLogicalNotOptions(builder);
  }
}

export class UnpackOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): UnpackOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsUnpackOptions(bb: flatbuffers.ByteBuffer, obj?: UnpackOptions): UnpackOptions {
    return (obj || new UnpackOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsUnpackOptions(bb: flatbuffers.ByteBuffer, obj?: UnpackOptions):
      UnpackOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new UnpackOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  num(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startUnpackOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addNum(builder: flatbuffers.Builder, num: number) {
    builder.addFieldInt32(0, num, 0);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(1, axis, 0);
  }

  static endUnpackOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createUnpackOptions(builder: flatbuffers.Builder, num: number, axis: number):
      flatbuffers.Offset {
    UnpackOptions.startUnpackOptions(builder);
    UnpackOptions.addNum(builder, num);
    UnpackOptions.addAxis(builder, axis);
    return UnpackOptions.endUnpackOptions(builder);
  }

  unpack(): UnpackOptionsT {
    return new UnpackOptionsT(this.num(), this.axis());
  }


  unpackTo(_o: UnpackOptionsT): void {
    _o.num = this.num();
    _o.axis = this.axis();
  }
}

export class UnpackOptionsT {
  constructor(public num: number = 0, public axis: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return UnpackOptions.createUnpackOptions(builder, this.num, this.axis);
  }
}

export class FloorDivOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): FloorDivOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsFloorDivOptions(bb: flatbuffers.ByteBuffer, obj?: FloorDivOptions):
      FloorDivOptions {
    return (obj || new FloorDivOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFloorDivOptions(bb: flatbuffers.ByteBuffer, obj?: FloorDivOptions):
      FloorDivOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new FloorDivOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startFloorDivOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endFloorDivOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createFloorDivOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    FloorDivOptions.startFloorDivOptions(builder);
    return FloorDivOptions.endFloorDivOptions(builder);
  }

  unpack(): FloorDivOptionsT {
    return new FloorDivOptionsT();
  }


  unpackTo(_o: FloorDivOptionsT): void {}
}

export class FloorDivOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return FloorDivOptions.createFloorDivOptions(builder);
  }
}

export class SquareOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SquareOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSquareOptions(bb: flatbuffers.ByteBuffer, obj?: SquareOptions): SquareOptions {
    return (obj || new SquareOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSquareOptions(bb: flatbuffers.ByteBuffer, obj?: SquareOptions):
      SquareOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SquareOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSquareOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSquareOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSquareOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SquareOptions.startSquareOptions(builder);
    return SquareOptions.endSquareOptions(builder);
  }

  unpack(): SquareOptionsT {
    return new SquareOptionsT();
  }


  unpackTo(_o: SquareOptionsT): void {}
}

export class SquareOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SquareOptions.createSquareOptions(builder);
  }
}

export class ZerosLikeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ZerosLikeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsZerosLikeOptions(bb: flatbuffers.ByteBuffer, obj?: ZerosLikeOptions):
      ZerosLikeOptions {
    return (obj || new ZerosLikeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsZerosLikeOptions(bb: flatbuffers.ByteBuffer, obj?: ZerosLikeOptions):
      ZerosLikeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ZerosLikeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startZerosLikeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endZerosLikeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createZerosLikeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    ZerosLikeOptions.startZerosLikeOptions(builder);
    return ZerosLikeOptions.endZerosLikeOptions(builder);
  }

  unpack(): ZerosLikeOptionsT {
    return new ZerosLikeOptionsT();
  }


  unpackTo(_o: ZerosLikeOptionsT): void {}
}

export class ZerosLikeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ZerosLikeOptions.createZerosLikeOptions(builder);
  }
}

export class FillOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): FillOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsFillOptions(bb: flatbuffers.ByteBuffer, obj?: FillOptions): FillOptions {
    return (obj || new FillOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFillOptions(bb: flatbuffers.ByteBuffer, obj?: FillOptions):
      FillOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new FillOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startFillOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endFillOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createFillOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    FillOptions.startFillOptions(builder);
    return FillOptions.endFillOptions(builder);
  }

  unpack(): FillOptionsT {
    return new FillOptionsT();
  }


  unpackTo(_o: FillOptionsT): void {}
}

export class FillOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return FillOptions.createFillOptions(builder);
  }
}

export class FloorModOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): FloorModOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsFloorModOptions(bb: flatbuffers.ByteBuffer, obj?: FloorModOptions):
      FloorModOptions {
    return (obj || new FloorModOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsFloorModOptions(bb: flatbuffers.ByteBuffer, obj?: FloorModOptions):
      FloorModOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new FloorModOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startFloorModOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endFloorModOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createFloorModOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    FloorModOptions.startFloorModOptions(builder);
    return FloorModOptions.endFloorModOptions(builder);
  }

  unpack(): FloorModOptionsT {
    return new FloorModOptionsT();
  }


  unpackTo(_o: FloorModOptionsT): void {}
}

export class FloorModOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return FloorModOptions.createFloorModOptions(builder);
  }
}

export class RangeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): RangeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsRangeOptions(bb: flatbuffers.ByteBuffer, obj?: RangeOptions): RangeOptions {
    return (obj || new RangeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsRangeOptions(bb: flatbuffers.ByteBuffer, obj?: RangeOptions):
      RangeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new RangeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startRangeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endRangeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createRangeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    RangeOptions.startRangeOptions(builder);
    return RangeOptions.endRangeOptions(builder);
  }

  unpack(): RangeOptionsT {
    return new RangeOptionsT();
  }


  unpackTo(_o: RangeOptionsT): void {}
}

export class RangeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return RangeOptions.createRangeOptions(builder);
  }
}

export class LeakyReluOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): LeakyReluOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsLeakyReluOptions(bb: flatbuffers.ByteBuffer, obj?: LeakyReluOptions):
      LeakyReluOptions {
    return (obj || new LeakyReluOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsLeakyReluOptions(bb: flatbuffers.ByteBuffer, obj?: LeakyReluOptions):
      LeakyReluOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new LeakyReluOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  alpha(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  static startLeakyReluOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addAlpha(builder: flatbuffers.Builder, alpha: number) {
    builder.addFieldFloat32(0, alpha, 0.0);
  }

  static endLeakyReluOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createLeakyReluOptions(builder: flatbuffers.Builder, alpha: number): flatbuffers.Offset {
    LeakyReluOptions.startLeakyReluOptions(builder);
    LeakyReluOptions.addAlpha(builder, alpha);
    return LeakyReluOptions.endLeakyReluOptions(builder);
  }

  unpack(): LeakyReluOptionsT {
    return new LeakyReluOptionsT(this.alpha());
  }


  unpackTo(_o: LeakyReluOptionsT): void {
    _o.alpha = this.alpha();
  }
}

export class LeakyReluOptionsT {
  constructor(public alpha: number = 0.0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return LeakyReluOptions.createLeakyReluOptions(builder, this.alpha);
  }
}

export class SquaredDifferenceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SquaredDifferenceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSquaredDifferenceOptions(
      bb: flatbuffers.ByteBuffer, obj?: SquaredDifferenceOptions): SquaredDifferenceOptions {
    return (obj || new SquaredDifferenceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSquaredDifferenceOptions(
      bb: flatbuffers.ByteBuffer, obj?: SquaredDifferenceOptions): SquaredDifferenceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SquaredDifferenceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSquaredDifferenceOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSquaredDifferenceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSquaredDifferenceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SquaredDifferenceOptions.startSquaredDifferenceOptions(builder);
    return SquaredDifferenceOptions.endSquaredDifferenceOptions(builder);
  }

  unpack(): SquaredDifferenceOptionsT {
    return new SquaredDifferenceOptionsT();
  }


  unpackTo(_o: SquaredDifferenceOptionsT): void {}
}

export class SquaredDifferenceOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SquaredDifferenceOptions.createSquaredDifferenceOptions(builder);
  }
}

export class MirrorPadOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): MirrorPadOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMirrorPadOptions(bb: flatbuffers.ByteBuffer, obj?: MirrorPadOptions):
      MirrorPadOptions {
    return (obj || new MirrorPadOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMirrorPadOptions(bb: flatbuffers.ByteBuffer, obj?: MirrorPadOptions):
      MirrorPadOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new MirrorPadOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  mode(): MirrorPadMode {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : MirrorPadMode.REFLECT;
  }

  static startMirrorPadOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addMode(builder: flatbuffers.Builder, mode: MirrorPadMode) {
    builder.addFieldInt8(0, mode, MirrorPadMode.REFLECT);
  }

  static endMirrorPadOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMirrorPadOptions(builder: flatbuffers.Builder, mode: MirrorPadMode):
      flatbuffers.Offset {
    MirrorPadOptions.startMirrorPadOptions(builder);
    MirrorPadOptions.addMode(builder, mode);
    return MirrorPadOptions.endMirrorPadOptions(builder);
  }

  unpack(): MirrorPadOptionsT {
    return new MirrorPadOptionsT(this.mode());
  }


  unpackTo(_o: MirrorPadOptionsT): void {
    _o.mode = this.mode();
  }
}

export class MirrorPadOptionsT {
  constructor(public mode: MirrorPadMode = MirrorPadMode.REFLECT) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return MirrorPadOptions.createMirrorPadOptions(builder, this.mode);
  }
}

export class UniqueOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): UniqueOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsUniqueOptions(bb: flatbuffers.ByteBuffer, obj?: UniqueOptions): UniqueOptions {
    return (obj || new UniqueOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsUniqueOptions(bb: flatbuffers.ByteBuffer, obj?: UniqueOptions):
      UniqueOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new UniqueOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  idxOutType(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.INT32;
  }

  static startUniqueOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addIdxOutType(builder: flatbuffers.Builder, idxOutType: TensorType) {
    builder.addFieldInt8(0, idxOutType, TensorType.INT32);
  }

  static endUniqueOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createUniqueOptions(builder: flatbuffers.Builder, idxOutType: TensorType):
      flatbuffers.Offset {
    UniqueOptions.startUniqueOptions(builder);
    UniqueOptions.addIdxOutType(builder, idxOutType);
    return UniqueOptions.endUniqueOptions(builder);
  }

  unpack(): UniqueOptionsT {
    return new UniqueOptionsT(this.idxOutType());
  }


  unpackTo(_o: UniqueOptionsT): void {
    _o.idxOutType = this.idxOutType();
  }
}

export class UniqueOptionsT {
  constructor(public idxOutType: TensorType = TensorType.INT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return UniqueOptions.createUniqueOptions(builder, this.idxOutType);
  }
}

export class ReverseV2Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ReverseV2Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsReverseV2Options(bb: flatbuffers.ByteBuffer, obj?: ReverseV2Options):
      ReverseV2Options {
    return (obj || new ReverseV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsReverseV2Options(bb: flatbuffers.ByteBuffer, obj?: ReverseV2Options):
      ReverseV2Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ReverseV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startReverseV2Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endReverseV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createReverseV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    ReverseV2Options.startReverseV2Options(builder);
    return ReverseV2Options.endReverseV2Options(builder);
  }

  unpack(): ReverseV2OptionsT {
    return new ReverseV2OptionsT();
  }


  unpackTo(_o: ReverseV2OptionsT): void {}
}

export class ReverseV2OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ReverseV2Options.createReverseV2Options(builder);
  }
}

export class AddNOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): AddNOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsAddNOptions(bb: flatbuffers.ByteBuffer, obj?: AddNOptions): AddNOptions {
    return (obj || new AddNOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsAddNOptions(bb: flatbuffers.ByteBuffer, obj?: AddNOptions):
      AddNOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new AddNOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startAddNOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endAddNOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createAddNOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    AddNOptions.startAddNOptions(builder);
    return AddNOptions.endAddNOptions(builder);
  }

  unpack(): AddNOptionsT {
    return new AddNOptionsT();
  }


  unpackTo(_o: AddNOptionsT): void {}
}

export class AddNOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return AddNOptions.createAddNOptions(builder);
  }
}

export class GatherNdOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): GatherNdOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsGatherNdOptions(bb: flatbuffers.ByteBuffer, obj?: GatherNdOptions):
      GatherNdOptions {
    return (obj || new GatherNdOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsGatherNdOptions(bb: flatbuffers.ByteBuffer, obj?: GatherNdOptions):
      GatherNdOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new GatherNdOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startGatherNdOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endGatherNdOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createGatherNdOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    GatherNdOptions.startGatherNdOptions(builder);
    return GatherNdOptions.endGatherNdOptions(builder);
  }

  unpack(): GatherNdOptionsT {
    return new GatherNdOptionsT();
  }


  unpackTo(_o: GatherNdOptionsT): void {}
}

export class GatherNdOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return GatherNdOptions.createGatherNdOptions(builder);
  }
}

export class WhereOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): WhereOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsWhereOptions(bb: flatbuffers.ByteBuffer, obj?: WhereOptions): WhereOptions {
    return (obj || new WhereOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsWhereOptions(bb: flatbuffers.ByteBuffer, obj?: WhereOptions):
      WhereOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new WhereOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startWhereOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endWhereOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createWhereOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    WhereOptions.startWhereOptions(builder);
    return WhereOptions.endWhereOptions(builder);
  }

  unpack(): WhereOptionsT {
    return new WhereOptionsT();
  }


  unpackTo(_o: WhereOptionsT): void {}
}

export class WhereOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return WhereOptions.createWhereOptions(builder);
  }
}

export class ReverseSequenceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ReverseSequenceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsReverseSequenceOptions(bb: flatbuffers.ByteBuffer, obj?: ReverseSequenceOptions):
      ReverseSequenceOptions {
    return (obj || new ReverseSequenceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsReverseSequenceOptions(
      bb: flatbuffers.ByteBuffer, obj?: ReverseSequenceOptions): ReverseSequenceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ReverseSequenceOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  seqDim(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  batchDim(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startReverseSequenceOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addSeqDim(builder: flatbuffers.Builder, seqDim: number) {
    builder.addFieldInt32(0, seqDim, 0);
  }

  static addBatchDim(builder: flatbuffers.Builder, batchDim: number) {
    builder.addFieldInt32(1, batchDim, 0);
  }

  static endReverseSequenceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createReverseSequenceOptions(
      builder: flatbuffers.Builder, seqDim: number, batchDim: number): flatbuffers.Offset {
    ReverseSequenceOptions.startReverseSequenceOptions(builder);
    ReverseSequenceOptions.addSeqDim(builder, seqDim);
    ReverseSequenceOptions.addBatchDim(builder, batchDim);
    return ReverseSequenceOptions.endReverseSequenceOptions(builder);
  }

  unpack(): ReverseSequenceOptionsT {
    return new ReverseSequenceOptionsT(this.seqDim(), this.batchDim());
  }


  unpackTo(_o: ReverseSequenceOptionsT): void {
    _o.seqDim = this.seqDim();
    _o.batchDim = this.batchDim();
  }
}

export class ReverseSequenceOptionsT {
  constructor(public seqDim: number = 0, public batchDim: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ReverseSequenceOptions.createReverseSequenceOptions(builder, this.seqDim, this.batchDim);
  }
}

export class MatrixDiagOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): MatrixDiagOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMatrixDiagOptions(bb: flatbuffers.ByteBuffer, obj?: MatrixDiagOptions):
      MatrixDiagOptions {
    return (obj || new MatrixDiagOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMatrixDiagOptions(
      bb: flatbuffers.ByteBuffer, obj?: MatrixDiagOptions): MatrixDiagOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new MatrixDiagOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startMatrixDiagOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endMatrixDiagOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMatrixDiagOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    MatrixDiagOptions.startMatrixDiagOptions(builder);
    return MatrixDiagOptions.endMatrixDiagOptions(builder);
  }

  unpack(): MatrixDiagOptionsT {
    return new MatrixDiagOptionsT();
  }


  unpackTo(_o: MatrixDiagOptionsT): void {}
}

export class MatrixDiagOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return MatrixDiagOptions.createMatrixDiagOptions(builder);
  }
}

export class QuantizeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): QuantizeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsQuantizeOptions(bb: flatbuffers.ByteBuffer, obj?: QuantizeOptions):
      QuantizeOptions {
    return (obj || new QuantizeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsQuantizeOptions(bb: flatbuffers.ByteBuffer, obj?: QuantizeOptions):
      QuantizeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new QuantizeOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startQuantizeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endQuantizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createQuantizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    QuantizeOptions.startQuantizeOptions(builder);
    return QuantizeOptions.endQuantizeOptions(builder);
  }

  unpack(): QuantizeOptionsT {
    return new QuantizeOptionsT();
  }


  unpackTo(_o: QuantizeOptionsT): void {}
}

export class QuantizeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return QuantizeOptions.createQuantizeOptions(builder);
  }
}

export class MatrixSetDiagOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): MatrixSetDiagOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMatrixSetDiagOptions(bb: flatbuffers.ByteBuffer, obj?: MatrixSetDiagOptions):
      MatrixSetDiagOptions {
    return (obj || new MatrixSetDiagOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMatrixSetDiagOptions(
      bb: flatbuffers.ByteBuffer, obj?: MatrixSetDiagOptions): MatrixSetDiagOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new MatrixSetDiagOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startMatrixSetDiagOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endMatrixSetDiagOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMatrixSetDiagOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    MatrixSetDiagOptions.startMatrixSetDiagOptions(builder);
    return MatrixSetDiagOptions.endMatrixSetDiagOptions(builder);
  }

  unpack(): MatrixSetDiagOptionsT {
    return new MatrixSetDiagOptionsT();
  }


  unpackTo(_o: MatrixSetDiagOptionsT): void {}
}

export class MatrixSetDiagOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return MatrixSetDiagOptions.createMatrixSetDiagOptions(builder);
  }
}

export class IfOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): IfOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsIfOptions(bb: flatbuffers.ByteBuffer, obj?: IfOptions): IfOptions {
    return (obj || new IfOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsIfOptions(bb: flatbuffers.ByteBuffer, obj?: IfOptions): IfOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new IfOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  thenSubgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  elseSubgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startIfOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addThenSubgraphIndex(builder: flatbuffers.Builder, thenSubgraphIndex: number) {
    builder.addFieldInt32(0, thenSubgraphIndex, 0);
  }

  static addElseSubgraphIndex(builder: flatbuffers.Builder, elseSubgraphIndex: number) {
    builder.addFieldInt32(1, elseSubgraphIndex, 0);
  }

  static endIfOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createIfOptions(
      builder: flatbuffers.Builder, thenSubgraphIndex: number,
      elseSubgraphIndex: number): flatbuffers.Offset {
    IfOptions.startIfOptions(builder);
    IfOptions.addThenSubgraphIndex(builder, thenSubgraphIndex);
    IfOptions.addElseSubgraphIndex(builder, elseSubgraphIndex);
    return IfOptions.endIfOptions(builder);
  }

  unpack(): IfOptionsT {
    return new IfOptionsT(this.thenSubgraphIndex(), this.elseSubgraphIndex());
  }


  unpackTo(_o: IfOptionsT): void {
    _o.thenSubgraphIndex = this.thenSubgraphIndex();
    _o.elseSubgraphIndex = this.elseSubgraphIndex();
  }
}

export class IfOptionsT {
  constructor(public thenSubgraphIndex: number = 0, public elseSubgraphIndex: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return IfOptions.createIfOptions(builder, this.thenSubgraphIndex, this.elseSubgraphIndex);
  }
}

export class CallOnceOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CallOnceOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCallOnceOptions(bb: flatbuffers.ByteBuffer, obj?: CallOnceOptions):
      CallOnceOptions {
    return (obj || new CallOnceOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCallOnceOptions(bb: flatbuffers.ByteBuffer, obj?: CallOnceOptions):
      CallOnceOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CallOnceOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  initSubgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startCallOnceOptions(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addInitSubgraphIndex(builder: flatbuffers.Builder, initSubgraphIndex: number) {
    builder.addFieldInt32(0, initSubgraphIndex, 0);
  }

  static endCallOnceOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCallOnceOptions(builder: flatbuffers.Builder, initSubgraphIndex: number):
      flatbuffers.Offset {
    CallOnceOptions.startCallOnceOptions(builder);
    CallOnceOptions.addInitSubgraphIndex(builder, initSubgraphIndex);
    return CallOnceOptions.endCallOnceOptions(builder);
  }

  unpack(): CallOnceOptionsT {
    return new CallOnceOptionsT(this.initSubgraphIndex());
  }


  unpackTo(_o: CallOnceOptionsT): void {
    _o.initSubgraphIndex = this.initSubgraphIndex();
  }
}

export class CallOnceOptionsT {
  constructor(public initSubgraphIndex: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return CallOnceOptions.createCallOnceOptions(builder, this.initSubgraphIndex);
  }
}

export class WhileOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): WhileOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsWhileOptions(bb: flatbuffers.ByteBuffer, obj?: WhileOptions): WhileOptions {
    return (obj || new WhileOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsWhileOptions(bb: flatbuffers.ByteBuffer, obj?: WhileOptions):
      WhileOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new WhileOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  condSubgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  bodySubgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startWhileOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addCondSubgraphIndex(builder: flatbuffers.Builder, condSubgraphIndex: number) {
    builder.addFieldInt32(0, condSubgraphIndex, 0);
  }

  static addBodySubgraphIndex(builder: flatbuffers.Builder, bodySubgraphIndex: number) {
    builder.addFieldInt32(1, bodySubgraphIndex, 0);
  }

  static endWhileOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createWhileOptions(
      builder: flatbuffers.Builder, condSubgraphIndex: number,
      bodySubgraphIndex: number): flatbuffers.Offset {
    WhileOptions.startWhileOptions(builder);
    WhileOptions.addCondSubgraphIndex(builder, condSubgraphIndex);
    WhileOptions.addBodySubgraphIndex(builder, bodySubgraphIndex);
    return WhileOptions.endWhileOptions(builder);
  }

  unpack(): WhileOptionsT {
    return new WhileOptionsT(this.condSubgraphIndex(), this.bodySubgraphIndex());
  }


  unpackTo(_o: WhileOptionsT): void {
    _o.condSubgraphIndex = this.condSubgraphIndex();
    _o.bodySubgraphIndex = this.bodySubgraphIndex();
  }
}

export class WhileOptionsT {
  constructor(public condSubgraphIndex: number = 0, public bodySubgraphIndex: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return WhileOptions.createWhileOptions(builder, this.condSubgraphIndex, this.bodySubgraphIndex);
  }
}

export class NonMaxSuppressionV4Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): NonMaxSuppressionV4Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsNonMaxSuppressionV4Options(
      bb: flatbuffers.ByteBuffer, obj?: NonMaxSuppressionV4Options): NonMaxSuppressionV4Options {
    return (obj || new NonMaxSuppressionV4Options())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsNonMaxSuppressionV4Options(
      bb: flatbuffers.ByteBuffer, obj?: NonMaxSuppressionV4Options): NonMaxSuppressionV4Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new NonMaxSuppressionV4Options())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startNonMaxSuppressionV4Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endNonMaxSuppressionV4Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createNonMaxSuppressionV4Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    NonMaxSuppressionV4Options.startNonMaxSuppressionV4Options(builder);
    return NonMaxSuppressionV4Options.endNonMaxSuppressionV4Options(builder);
  }

  unpack(): NonMaxSuppressionV4OptionsT {
    return new NonMaxSuppressionV4OptionsT();
  }


  unpackTo(_o: NonMaxSuppressionV4OptionsT): void {}
}

export class NonMaxSuppressionV4OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return NonMaxSuppressionV4Options.createNonMaxSuppressionV4Options(builder);
  }
}

export class NonMaxSuppressionV5Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): NonMaxSuppressionV5Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsNonMaxSuppressionV5Options(
      bb: flatbuffers.ByteBuffer, obj?: NonMaxSuppressionV5Options): NonMaxSuppressionV5Options {
    return (obj || new NonMaxSuppressionV5Options())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsNonMaxSuppressionV5Options(
      bb: flatbuffers.ByteBuffer, obj?: NonMaxSuppressionV5Options): NonMaxSuppressionV5Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new NonMaxSuppressionV5Options())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startNonMaxSuppressionV5Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endNonMaxSuppressionV5Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createNonMaxSuppressionV5Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    NonMaxSuppressionV5Options.startNonMaxSuppressionV5Options(builder);
    return NonMaxSuppressionV5Options.endNonMaxSuppressionV5Options(builder);
  }

  unpack(): NonMaxSuppressionV5OptionsT {
    return new NonMaxSuppressionV5OptionsT();
  }


  unpackTo(_o: NonMaxSuppressionV5OptionsT): void {}
}

export class NonMaxSuppressionV5OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return NonMaxSuppressionV5Options.createNonMaxSuppressionV5Options(builder);
  }
}

export class ScatterNdOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ScatterNdOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsScatterNdOptions(bb: flatbuffers.ByteBuffer, obj?: ScatterNdOptions):
      ScatterNdOptions {
    return (obj || new ScatterNdOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsScatterNdOptions(bb: flatbuffers.ByteBuffer, obj?: ScatterNdOptions):
      ScatterNdOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ScatterNdOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startScatterNdOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endScatterNdOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createScatterNdOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    ScatterNdOptions.startScatterNdOptions(builder);
    return ScatterNdOptions.endScatterNdOptions(builder);
  }

  unpack(): ScatterNdOptionsT {
    return new ScatterNdOptionsT();
  }


  unpackTo(_o: ScatterNdOptionsT): void {}
}

export class ScatterNdOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ScatterNdOptions.createScatterNdOptions(builder);
  }
}

export class SelectV2Options {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SelectV2Options {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSelectV2Options(bb: flatbuffers.ByteBuffer, obj?: SelectV2Options):
      SelectV2Options {
    return (obj || new SelectV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSelectV2Options(bb: flatbuffers.ByteBuffer, obj?: SelectV2Options):
      SelectV2Options {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SelectV2Options()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSelectV2Options(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSelectV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSelectV2Options(builder: flatbuffers.Builder): flatbuffers.Offset {
    SelectV2Options.startSelectV2Options(builder);
    return SelectV2Options.endSelectV2Options(builder);
  }

  unpack(): SelectV2OptionsT {
    return new SelectV2OptionsT();
  }


  unpackTo(_o: SelectV2OptionsT): void {}
}

export class SelectV2OptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SelectV2Options.createSelectV2Options(builder);
  }
}

export class DensifyOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): DensifyOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsDensifyOptions(bb: flatbuffers.ByteBuffer, obj?: DensifyOptions): DensifyOptions {
    return (obj || new DensifyOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsDensifyOptions(bb: flatbuffers.ByteBuffer, obj?: DensifyOptions):
      DensifyOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new DensifyOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startDensifyOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endDensifyOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createDensifyOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    DensifyOptions.startDensifyOptions(builder);
    return DensifyOptions.endDensifyOptions(builder);
  }

  unpack(): DensifyOptionsT {
    return new DensifyOptionsT();
  }


  unpackTo(_o: DensifyOptionsT): void {}
}

export class DensifyOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return DensifyOptions.createDensifyOptions(builder);
  }
}

export class SegmentSumOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SegmentSumOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSegmentSumOptions(bb: flatbuffers.ByteBuffer, obj?: SegmentSumOptions):
      SegmentSumOptions {
    return (obj || new SegmentSumOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSegmentSumOptions(
      bb: flatbuffers.ByteBuffer, obj?: SegmentSumOptions): SegmentSumOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SegmentSumOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startSegmentSumOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endSegmentSumOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSegmentSumOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    SegmentSumOptions.startSegmentSumOptions(builder);
    return SegmentSumOptions.endSegmentSumOptions(builder);
  }

  unpack(): SegmentSumOptionsT {
    return new SegmentSumOptionsT();
  }


  unpackTo(_o: SegmentSumOptionsT): void {}
}

export class SegmentSumOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return SegmentSumOptions.createSegmentSumOptions(builder);
  }
}

export class BatchMatMulOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BatchMatMulOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBatchMatMulOptions(bb: flatbuffers.ByteBuffer, obj?: BatchMatMulOptions):
      BatchMatMulOptions {
    return (obj || new BatchMatMulOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBatchMatMulOptions(
      bb: flatbuffers.ByteBuffer, obj?: BatchMatMulOptions): BatchMatMulOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BatchMatMulOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  adjointLhs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  adjointRhs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  asymmetricQuantizeInputs(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startBatchMatMulOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addAdjointLhs(builder: flatbuffers.Builder, adjointLhs: boolean) {
    builder.addFieldInt8(0, +adjointLhs, +false);
  }

  static addAdjointRhs(builder: flatbuffers.Builder, adjointRhs: boolean) {
    builder.addFieldInt8(1, +adjointRhs, +false);
  }

  static addAsymmetricQuantizeInputs(
      builder: flatbuffers.Builder, asymmetricQuantizeInputs: boolean) {
    builder.addFieldInt8(2, +asymmetricQuantizeInputs, +false);
  }

  static endBatchMatMulOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBatchMatMulOptions(
      builder: flatbuffers.Builder, adjointLhs: boolean, adjointRhs: boolean,
      asymmetricQuantizeInputs: boolean): flatbuffers.Offset {
    BatchMatMulOptions.startBatchMatMulOptions(builder);
    BatchMatMulOptions.addAdjointLhs(builder, adjointLhs);
    BatchMatMulOptions.addAdjointRhs(builder, adjointRhs);
    BatchMatMulOptions.addAsymmetricQuantizeInputs(builder, asymmetricQuantizeInputs);
    return BatchMatMulOptions.endBatchMatMulOptions(builder);
  }

  unpack(): BatchMatMulOptionsT {
    return new BatchMatMulOptionsT(
        this.adjointLhs(), this.adjointRhs(), this.asymmetricQuantizeInputs());
  }


  unpackTo(_o: BatchMatMulOptionsT): void {
    _o.adjointLhs = this.adjointLhs();
    _o.adjointRhs = this.adjointRhs();
    _o.asymmetricQuantizeInputs = this.asymmetricQuantizeInputs();
  }
}

export class BatchMatMulOptionsT {
  constructor(
      public adjointLhs: boolean = false, public adjointRhs: boolean = false,
      public asymmetricQuantizeInputs: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BatchMatMulOptions.createBatchMatMulOptions(
        builder, this.adjointLhs, this.adjointRhs, this.asymmetricQuantizeInputs);
  }
}

export class CumsumOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): CumsumOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsCumsumOptions(bb: flatbuffers.ByteBuffer, obj?: CumsumOptions): CumsumOptions {
    return (obj || new CumsumOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsCumsumOptions(bb: flatbuffers.ByteBuffer, obj?: CumsumOptions):
      CumsumOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new CumsumOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  exclusive(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  reverse(): boolean {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? !!this.bb!.readInt8(this.bb_pos + offset) : false;
  }

  static startCumsumOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addExclusive(builder: flatbuffers.Builder, exclusive: boolean) {
    builder.addFieldInt8(0, +exclusive, +false);
  }

  static addReverse(builder: flatbuffers.Builder, reverse: boolean) {
    builder.addFieldInt8(1, +reverse, +false);
  }

  static endCumsumOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createCumsumOptions(builder: flatbuffers.Builder, exclusive: boolean, reverse: boolean):
      flatbuffers.Offset {
    CumsumOptions.startCumsumOptions(builder);
    CumsumOptions.addExclusive(builder, exclusive);
    CumsumOptions.addReverse(builder, reverse);
    return CumsumOptions.endCumsumOptions(builder);
  }

  unpack(): CumsumOptionsT {
    return new CumsumOptionsT(this.exclusive(), this.reverse());
  }


  unpackTo(_o: CumsumOptionsT): void {
    _o.exclusive = this.exclusive();
    _o.reverse = this.reverse();
  }
}

export class CumsumOptionsT {
  constructor(public exclusive: boolean = false, public reverse: boolean = false) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return CumsumOptions.createCumsumOptions(builder, this.exclusive, this.reverse);
  }
}

export class BroadcastToOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BroadcastToOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBroadcastToOptions(bb: flatbuffers.ByteBuffer, obj?: BroadcastToOptions):
      BroadcastToOptions {
    return (obj || new BroadcastToOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBroadcastToOptions(
      bb: flatbuffers.ByteBuffer, obj?: BroadcastToOptions): BroadcastToOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BroadcastToOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startBroadcastToOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endBroadcastToOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBroadcastToOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    BroadcastToOptions.startBroadcastToOptions(builder);
    return BroadcastToOptions.endBroadcastToOptions(builder);
  }

  unpack(): BroadcastToOptionsT {
    return new BroadcastToOptionsT();
  }


  unpackTo(_o: BroadcastToOptionsT): void {}
}

export class BroadcastToOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BroadcastToOptions.createBroadcastToOptions(builder);
  }
}

export class Rfft2dOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Rfft2dOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsRfft2dOptions(bb: flatbuffers.ByteBuffer, obj?: Rfft2dOptions): Rfft2dOptions {
    return (obj || new Rfft2dOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsRfft2dOptions(bb: flatbuffers.ByteBuffer, obj?: Rfft2dOptions):
      Rfft2dOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Rfft2dOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startRfft2dOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endRfft2dOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createRfft2dOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    Rfft2dOptions.startRfft2dOptions(builder);
    return Rfft2dOptions.endRfft2dOptions(builder);
  }

  unpack(): Rfft2dOptionsT {
    return new Rfft2dOptionsT();
  }


  unpackTo(_o: Rfft2dOptionsT): void {}
}

export class Rfft2dOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return Rfft2dOptions.createRfft2dOptions(builder);
  }
}

export class HashtableOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): HashtableOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsHashtableOptions(bb: flatbuffers.ByteBuffer, obj?: HashtableOptions):
      HashtableOptions {
    return (obj || new HashtableOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsHashtableOptions(bb: flatbuffers.ByteBuffer, obj?: HashtableOptions):
      HashtableOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new HashtableOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  tableId(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  keyDtype(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  valueDtype(): TensorType {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : TensorType.FLOAT32;
  }

  static startHashtableOptions(builder: flatbuffers.Builder) {
    builder.startObject(3);
  }

  static addTableId(builder: flatbuffers.Builder, tableId: number) {
    builder.addFieldInt32(0, tableId, 0);
  }

  static addKeyDtype(builder: flatbuffers.Builder, keyDtype: TensorType) {
    builder.addFieldInt8(1, keyDtype, TensorType.FLOAT32);
  }

  static addValueDtype(builder: flatbuffers.Builder, valueDtype: TensorType) {
    builder.addFieldInt8(2, valueDtype, TensorType.FLOAT32);
  }

  static endHashtableOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createHashtableOptions(
      builder: flatbuffers.Builder, tableId: number, keyDtype: TensorType,
      valueDtype: TensorType): flatbuffers.Offset {
    HashtableOptions.startHashtableOptions(builder);
    HashtableOptions.addTableId(builder, tableId);
    HashtableOptions.addKeyDtype(builder, keyDtype);
    HashtableOptions.addValueDtype(builder, valueDtype);
    return HashtableOptions.endHashtableOptions(builder);
  }

  unpack(): HashtableOptionsT {
    return new HashtableOptionsT(this.tableId(), this.keyDtype(), this.valueDtype());
  }


  unpackTo(_o: HashtableOptionsT): void {
    _o.tableId = this.tableId();
    _o.keyDtype = this.keyDtype();
    _o.valueDtype = this.valueDtype();
  }
}

export class HashtableOptionsT {
  constructor(
      public tableId: number = 0, public keyDtype: TensorType = TensorType.FLOAT32,
      public valueDtype: TensorType = TensorType.FLOAT32) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return HashtableOptions.createHashtableOptions(
        builder, this.tableId, this.keyDtype, this.valueDtype);
  }
}

export class HashtableFindOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): HashtableFindOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsHashtableFindOptions(bb: flatbuffers.ByteBuffer, obj?: HashtableFindOptions):
      HashtableFindOptions {
    return (obj || new HashtableFindOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsHashtableFindOptions(
      bb: flatbuffers.ByteBuffer, obj?: HashtableFindOptions): HashtableFindOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new HashtableFindOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startHashtableFindOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endHashtableFindOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createHashtableFindOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    HashtableFindOptions.startHashtableFindOptions(builder);
    return HashtableFindOptions.endHashtableFindOptions(builder);
  }

  unpack(): HashtableFindOptionsT {
    return new HashtableFindOptionsT();
  }


  unpackTo(_o: HashtableFindOptionsT): void {}
}

export class HashtableFindOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return HashtableFindOptions.createHashtableFindOptions(builder);
  }
}

export class HashtableImportOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): HashtableImportOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsHashtableImportOptions(bb: flatbuffers.ByteBuffer, obj?: HashtableImportOptions):
      HashtableImportOptions {
    return (obj || new HashtableImportOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsHashtableImportOptions(
      bb: flatbuffers.ByteBuffer, obj?: HashtableImportOptions): HashtableImportOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new HashtableImportOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startHashtableImportOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endHashtableImportOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createHashtableImportOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    HashtableImportOptions.startHashtableImportOptions(builder);
    return HashtableImportOptions.endHashtableImportOptions(builder);
  }

  unpack(): HashtableImportOptionsT {
    return new HashtableImportOptionsT();
  }


  unpackTo(_o: HashtableImportOptionsT): void {}
}

export class HashtableImportOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return HashtableImportOptions.createHashtableImportOptions(builder);
  }
}

export class HashtableSizeOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): HashtableSizeOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsHashtableSizeOptions(bb: flatbuffers.ByteBuffer, obj?: HashtableSizeOptions):
      HashtableSizeOptions {
    return (obj || new HashtableSizeOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsHashtableSizeOptions(
      bb: flatbuffers.ByteBuffer, obj?: HashtableSizeOptions): HashtableSizeOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new HashtableSizeOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startHashtableSizeOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endHashtableSizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createHashtableSizeOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    HashtableSizeOptions.startHashtableSizeOptions(builder);
    return HashtableSizeOptions.endHashtableSizeOptions(builder);
  }

  unpack(): HashtableSizeOptionsT {
    return new HashtableSizeOptionsT();
  }


  unpackTo(_o: HashtableSizeOptionsT): void {}
}

export class HashtableSizeOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return HashtableSizeOptions.createHashtableSizeOptions(builder);
  }
}

export class VarHandleOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): VarHandleOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsVarHandleOptions(bb: flatbuffers.ByteBuffer, obj?: VarHandleOptions):
      VarHandleOptions {
    return (obj || new VarHandleOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsVarHandleOptions(bb: flatbuffers.ByteBuffer, obj?: VarHandleOptions):
      VarHandleOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new VarHandleOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  container(): string|null
  container(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  container(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  sharedName(): string|null
  sharedName(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  sharedName(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  static startVarHandleOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addContainer(builder: flatbuffers.Builder, containerOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, containerOffset, 0);
  }

  static addSharedName(builder: flatbuffers.Builder, sharedNameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, sharedNameOffset, 0);
  }

  static endVarHandleOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createVarHandleOptions(
      builder: flatbuffers.Builder, containerOffset: flatbuffers.Offset,
      sharedNameOffset: flatbuffers.Offset): flatbuffers.Offset {
    VarHandleOptions.startVarHandleOptions(builder);
    VarHandleOptions.addContainer(builder, containerOffset);
    VarHandleOptions.addSharedName(builder, sharedNameOffset);
    return VarHandleOptions.endVarHandleOptions(builder);
  }

  unpack(): VarHandleOptionsT {
    return new VarHandleOptionsT(this.container(), this.sharedName());
  }


  unpackTo(_o: VarHandleOptionsT): void {
    _o.container = this.container();
    _o.sharedName = this.sharedName();
  }
}

export class VarHandleOptionsT {
  constructor(
      public container: string|Uint8Array|null = null,
      public sharedName: string|Uint8Array|null = null) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const container = (this.container !== null ? builder.createString(this.container!) : 0);
    const sharedName = (this.sharedName !== null ? builder.createString(this.sharedName!) : 0);

    return VarHandleOptions.createVarHandleOptions(builder, container, sharedName);
  }
}

export class ReadVariableOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): ReadVariableOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsReadVariableOptions(bb: flatbuffers.ByteBuffer, obj?: ReadVariableOptions):
      ReadVariableOptions {
    return (obj || new ReadVariableOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsReadVariableOptions(
      bb: flatbuffers.ByteBuffer, obj?: ReadVariableOptions): ReadVariableOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new ReadVariableOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startReadVariableOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endReadVariableOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createReadVariableOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    ReadVariableOptions.startReadVariableOptions(builder);
    return ReadVariableOptions.endReadVariableOptions(builder);
  }

  unpack(): ReadVariableOptionsT {
    return new ReadVariableOptionsT();
  }


  unpackTo(_o: ReadVariableOptionsT): void {}
}

export class ReadVariableOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return ReadVariableOptions.createReadVariableOptions(builder);
  }
}

export class AssignVariableOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): AssignVariableOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsAssignVariableOptions(bb: flatbuffers.ByteBuffer, obj?: AssignVariableOptions):
      AssignVariableOptions {
    return (obj || new AssignVariableOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsAssignVariableOptions(
      bb: flatbuffers.ByteBuffer, obj?: AssignVariableOptions): AssignVariableOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new AssignVariableOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static startAssignVariableOptions(builder: flatbuffers.Builder) {
    builder.startObject(0);
  }

  static endAssignVariableOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createAssignVariableOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    AssignVariableOptions.startAssignVariableOptions(builder);
    return AssignVariableOptions.endAssignVariableOptions(builder);
  }

  unpack(): AssignVariableOptionsT {
    return new AssignVariableOptionsT();
  }


  unpackTo(_o: AssignVariableOptionsT): void {}
}

export class AssignVariableOptionsT {
  constructor() {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return AssignVariableOptions.createAssignVariableOptions(builder);
  }
}

export class RandomOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): RandomOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsRandomOptions(bb: flatbuffers.ByteBuffer, obj?: RandomOptions): RandomOptions {
    return (obj || new RandomOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsRandomOptions(bb: flatbuffers.ByteBuffer, obj?: RandomOptions):
      RandomOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new RandomOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  seed(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  seed2(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startRandomOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addSeed(builder: flatbuffers.Builder, seed: number) {
    builder.addFieldInt32(0, seed, 0);
  }

  static addSeed2(builder: flatbuffers.Builder, seed2: number) {
    builder.addFieldInt32(1, seed2, 0);
  }

  static endRandomOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createRandomOptions(builder: flatbuffers.Builder, seed: number, seed2: number):
      flatbuffers.Offset {
    RandomOptions.startRandomOptions(builder);
    RandomOptions.addSeed(builder, seed);
    RandomOptions.addSeed2(builder, seed2);
    return RandomOptions.endRandomOptions(builder);
  }

  unpack(): RandomOptionsT {
    return new RandomOptionsT(this.seed(), this.seed2());
  }


  unpackTo(_o: RandomOptionsT): void {
    _o.seed = this.seed();
    _o.seed2 = this.seed2();
  }
}

export class RandomOptionsT {
  constructor(public seed: number = 0, public seed2: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return RandomOptions.createRandomOptions(builder, this.seed, this.seed2);
  }
}

export class BCQGatherOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BCQGatherOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBCQGatherOptions(bb: flatbuffers.ByteBuffer, obj?: BCQGatherOptions):
      BCQGatherOptions {
    return (obj || new BCQGatherOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBCQGatherOptions(bb: flatbuffers.ByteBuffer, obj?: BCQGatherOptions):
      BCQGatherOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BCQGatherOptions()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  inputHiddenSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  axis(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  static startBCQGatherOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addInputHiddenSize(builder: flatbuffers.Builder, inputHiddenSize: number) {
    builder.addFieldInt32(0, inputHiddenSize, 0);
  }

  static addAxis(builder: flatbuffers.Builder, axis: number) {
    builder.addFieldInt32(1, axis, 0);
  }

  static endBCQGatherOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBCQGatherOptions(
      builder: flatbuffers.Builder, inputHiddenSize: number, axis: number): flatbuffers.Offset {
    BCQGatherOptions.startBCQGatherOptions(builder);
    BCQGatherOptions.addInputHiddenSize(builder, inputHiddenSize);
    BCQGatherOptions.addAxis(builder, axis);
    return BCQGatherOptions.endBCQGatherOptions(builder);
  }

  unpack(): BCQGatherOptionsT {
    return new BCQGatherOptionsT(this.inputHiddenSize(), this.axis());
  }


  unpackTo(_o: BCQGatherOptionsT): void {
    _o.inputHiddenSize = this.inputHiddenSize();
    _o.axis = this.axis();
  }
}

export class BCQGatherOptionsT {
  constructor(public inputHiddenSize: number = 0, public axis: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BCQGatherOptions.createBCQGatherOptions(builder, this.inputHiddenSize, this.axis);
  }
}

export class BCQFullyConnectedOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): BCQFullyConnectedOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBCQFullyConnectedOptions(
      bb: flatbuffers.ByteBuffer, obj?: BCQFullyConnectedOptions): BCQFullyConnectedOptions {
    return (obj || new BCQFullyConnectedOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBCQFullyConnectedOptions(
      bb: flatbuffers.ByteBuffer, obj?: BCQFullyConnectedOptions): BCQFullyConnectedOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new BCQFullyConnectedOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  weightsHiddenSize(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startBCQFullyConnectedOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addWeightsHiddenSize(builder: flatbuffers.Builder, weightsHiddenSize: number) {
    builder.addFieldInt32(0, weightsHiddenSize, 0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endBCQFullyConnectedOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBCQFullyConnectedOptions(
      builder: flatbuffers.Builder, weightsHiddenSize: number,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    BCQFullyConnectedOptions.startBCQFullyConnectedOptions(builder);
    BCQFullyConnectedOptions.addWeightsHiddenSize(builder, weightsHiddenSize);
    BCQFullyConnectedOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return BCQFullyConnectedOptions.endBCQFullyConnectedOptions(builder);
  }

  unpack(): BCQFullyConnectedOptionsT {
    return new BCQFullyConnectedOptionsT(this.weightsHiddenSize(), this.fusedActivationFunction());
  }


  unpackTo(_o: BCQFullyConnectedOptionsT): void {
    _o.weightsHiddenSize = this.weightsHiddenSize();
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class BCQFullyConnectedOptionsT {
  constructor(
      public weightsHiddenSize: number = 0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return BCQFullyConnectedOptions.createBCQFullyConnectedOptions(
        builder, this.weightsHiddenSize, this.fusedActivationFunction);
  }
}

export class InstanceNormOptions {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): InstanceNormOptions {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsInstanceNormOptions(bb: flatbuffers.ByteBuffer, obj?: InstanceNormOptions):
      InstanceNormOptions {
    return (obj || new InstanceNormOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsInstanceNormOptions(
      bb: flatbuffers.ByteBuffer, obj?: InstanceNormOptions): InstanceNormOptions {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new InstanceNormOptions())
        .__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  epsilon(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readFloat32(this.bb_pos + offset) : 0.0;
  }

  fusedActivationFunction(): ActivationFunctionType {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : ActivationFunctionType.NONE;
  }

  static startInstanceNormOptions(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addEpsilon(builder: flatbuffers.Builder, epsilon: number) {
    builder.addFieldFloat32(0, epsilon, 0.0);
  }

  static addFusedActivationFunction(
      builder: flatbuffers.Builder, fusedActivationFunction: ActivationFunctionType) {
    builder.addFieldInt8(1, fusedActivationFunction, ActivationFunctionType.NONE);
  }

  static endInstanceNormOptions(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createInstanceNormOptions(
      builder: flatbuffers.Builder, epsilon: number,
      fusedActivationFunction: ActivationFunctionType): flatbuffers.Offset {
    InstanceNormOptions.startInstanceNormOptions(builder);
    InstanceNormOptions.addEpsilon(builder, epsilon);
    InstanceNormOptions.addFusedActivationFunction(builder, fusedActivationFunction);
    return InstanceNormOptions.endInstanceNormOptions(builder);
  }

  unpack(): InstanceNormOptionsT {
    return new InstanceNormOptionsT(this.epsilon(), this.fusedActivationFunction());
  }


  unpackTo(_o: InstanceNormOptionsT): void {
    _o.epsilon = this.epsilon();
    _o.fusedActivationFunction = this.fusedActivationFunction();
  }
}

export class InstanceNormOptionsT {
  constructor(
      public epsilon: number = 0.0,
      public fusedActivationFunction: ActivationFunctionType = ActivationFunctionType.NONE) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    return InstanceNormOptions.createInstanceNormOptions(
        builder, this.epsilon, this.fusedActivationFunction);
  }
}

export class OperatorCode {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): OperatorCode {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsOperatorCode(bb: flatbuffers.ByteBuffer, obj?: OperatorCode): OperatorCode {
    return (obj || new OperatorCode()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsOperatorCode(bb: flatbuffers.ByteBuffer, obj?: OperatorCode):
      OperatorCode {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new OperatorCode()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  deprecatedBuiltinCode(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : 0;
  }

  customCode(): string|null
  customCode(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  customCode(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  version(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : 1;
  }

  builtinCode(): BuiltinOperator {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readInt32(this.bb_pos + offset) : BuiltinOperator.ADD;
  }

  static startOperatorCode(builder: flatbuffers.Builder) {
    builder.startObject(4);
  }

  static addDeprecatedBuiltinCode(builder: flatbuffers.Builder, deprecatedBuiltinCode: number) {
    builder.addFieldInt8(0, deprecatedBuiltinCode, 0);
  }

  static addCustomCode(builder: flatbuffers.Builder, customCodeOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, customCodeOffset, 0);
  }

  static addVersion(builder: flatbuffers.Builder, version: number) {
    builder.addFieldInt32(2, version, 1);
  }

  static addBuiltinCode(builder: flatbuffers.Builder, builtinCode: BuiltinOperator) {
    builder.addFieldInt32(3, builtinCode, BuiltinOperator.ADD);
  }

  static endOperatorCode(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createOperatorCode(
      builder: flatbuffers.Builder, deprecatedBuiltinCode: number,
      customCodeOffset: flatbuffers.Offset, version: number,
      builtinCode: BuiltinOperator): flatbuffers.Offset {
    OperatorCode.startOperatorCode(builder);
    OperatorCode.addDeprecatedBuiltinCode(builder, deprecatedBuiltinCode);
    OperatorCode.addCustomCode(builder, customCodeOffset);
    OperatorCode.addVersion(builder, version);
    OperatorCode.addBuiltinCode(builder, builtinCode);
    return OperatorCode.endOperatorCode(builder);
  }

  unpack(): OperatorCodeT {
    return new OperatorCodeT(
        this.deprecatedBuiltinCode(), this.customCode(), this.version(), this.builtinCode());
  }


  unpackTo(_o: OperatorCodeT): void {
    _o.deprecatedBuiltinCode = this.deprecatedBuiltinCode();
    _o.customCode = this.customCode();
    _o.version = this.version();
    _o.builtinCode = this.builtinCode();
  }
}

export class OperatorCodeT {
  constructor(
      public deprecatedBuiltinCode: number = 0, public customCode: string|Uint8Array|null = null,
      public version: number = 1, public builtinCode: BuiltinOperator = BuiltinOperator.ADD) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const customCode = (this.customCode !== null ? builder.createString(this.customCode!) : 0);

    return OperatorCode.createOperatorCode(
        builder, this.deprecatedBuiltinCode, customCode, this.version, this.builtinCode);
  }
}

export class Operator {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Operator {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsOperator(bb: flatbuffers.ByteBuffer, obj?: Operator): Operator {
    return (obj || new Operator()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsOperator(bb: flatbuffers.ByteBuffer, obj?: Operator): Operator {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Operator()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  opcodeIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  inputs(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  inputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  inputsArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  outputs(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  outputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  outputsArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  builtinOptionsType(): BuiltinOptions {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.readUint8(this.bb_pos + offset) : BuiltinOptions.NONE;
  }

  builtinOptions<T extends flatbuffers.Table>(obj: any): any|null {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.__union(obj, this.bb_pos + offset) : null;
  }

  customOptions(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
  }

  customOptionsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  customOptionsArray(): Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? new Uint8Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  customOptionsFormat(): CustomOptionsFormat {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : CustomOptionsFormat.FLEXBUFFERS;
  }

  mutatingVariableInputs(index: number): boolean|null {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? !!this.bb!.readInt8(this.bb!.__vector(this.bb_pos + offset) + index) : false;
  }

  mutatingVariableInputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  mutatingVariableInputsArray(): Int8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? new Int8Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  intermediates(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 20);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  intermediatesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 20);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  intermediatesArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 20);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startOperator(builder: flatbuffers.Builder) {
    builder.startObject(9);
  }

  static addOpcodeIndex(builder: flatbuffers.Builder, opcodeIndex: number) {
    builder.addFieldInt32(0, opcodeIndex, 0);
  }

  static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, inputsOffset, 0);
  }

  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startInputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, outputsOffset, 0);
  }

  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addBuiltinOptionsType(builder: flatbuffers.Builder, builtinOptionsType: BuiltinOptions) {
    builder.addFieldInt8(3, builtinOptionsType, BuiltinOptions.NONE);
  }

  static addBuiltinOptions(builder: flatbuffers.Builder, builtinOptionsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(4, builtinOptionsOffset, 0);
  }

  static addCustomOptions(builder: flatbuffers.Builder, customOptionsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(5, customOptionsOffset, 0);
  }

  static createCustomOptionsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(1, data.length, 1);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!);
    }
    return builder.endVector();
  }

  static startCustomOptionsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1);
  }

  static addCustomOptionsFormat(
      builder: flatbuffers.Builder, customOptionsFormat: CustomOptionsFormat) {
    builder.addFieldInt8(6, customOptionsFormat, CustomOptionsFormat.FLEXBUFFERS);
  }

  static addMutatingVariableInputs(
      builder: flatbuffers.Builder, mutatingVariableInputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(7, mutatingVariableInputsOffset, 0);
  }

  static createMutatingVariableInputsVector(builder: flatbuffers.Builder, data: boolean[]):
      flatbuffers.Offset {
    builder.startVector(1, data.length, 1);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(+data[i]!);
    }
    return builder.endVector();
  }

  static startMutatingVariableInputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1);
  }

  static addIntermediates(builder: flatbuffers.Builder, intermediatesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(8, intermediatesOffset, 0);
  }

  static createIntermediatesVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createIntermediatesVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createIntermediatesVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startIntermediatesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endOperator(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createOperator(
      builder: flatbuffers.Builder, opcodeIndex: number, inputsOffset: flatbuffers.Offset,
      outputsOffset: flatbuffers.Offset, builtinOptionsType: BuiltinOptions,
      builtinOptionsOffset: flatbuffers.Offset, customOptionsOffset: flatbuffers.Offset,
      customOptionsFormat: CustomOptionsFormat, mutatingVariableInputsOffset: flatbuffers.Offset,
      intermediatesOffset: flatbuffers.Offset): flatbuffers.Offset {
    Operator.startOperator(builder);
    Operator.addOpcodeIndex(builder, opcodeIndex);
    Operator.addInputs(builder, inputsOffset);
    Operator.addOutputs(builder, outputsOffset);
    Operator.addBuiltinOptionsType(builder, builtinOptionsType);
    Operator.addBuiltinOptions(builder, builtinOptionsOffset);
    Operator.addCustomOptions(builder, customOptionsOffset);
    Operator.addCustomOptionsFormat(builder, customOptionsFormat);
    Operator.addMutatingVariableInputs(builder, mutatingVariableInputsOffset);
    Operator.addIntermediates(builder, intermediatesOffset);
    return Operator.endOperator(builder);
  }

  unpack(): OperatorT {
    return new OperatorT(
        this.opcodeIndex(), this.bb!.createScalarList(this.inputs.bind(this), this.inputsLength()),
        this.bb!.createScalarList(this.outputs.bind(this), this.outputsLength()),
        this.builtinOptionsType(), (() => {
          let temp =
              unionToBuiltinOptions(this.builtinOptionsType(), this.builtinOptions.bind(this));
          if (temp === null) {
            return null;
          }
          return temp.unpack()
        })(),
        this.bb!.createScalarList(this.customOptions.bind(this), this.customOptionsLength()),
        this.customOptionsFormat(),
        this.bb!.createScalarList(
            this.mutatingVariableInputs.bind(this), this.mutatingVariableInputsLength()),
        this.bb!.createScalarList(this.intermediates.bind(this), this.intermediatesLength()));
  }


  unpackTo(_o: OperatorT): void {
    _o.opcodeIndex = this.opcodeIndex();
    _o.inputs = this.bb!.createScalarList(this.inputs.bind(this), this.inputsLength());
    _o.outputs = this.bb!.createScalarList(this.outputs.bind(this), this.outputsLength());
    _o.builtinOptionsType = this.builtinOptionsType();
    _o.builtinOptions = (() => {
      let temp = unionToBuiltinOptions(this.builtinOptionsType(), this.builtinOptions.bind(this));
      if (temp === null) {
        return null;
      }
      return temp.unpack()
    })();
    _o.customOptions =
        this.bb!.createScalarList(this.customOptions.bind(this), this.customOptionsLength());
    _o.customOptionsFormat = this.customOptionsFormat();
    _o.mutatingVariableInputs = this.bb!.createScalarList(
        this.mutatingVariableInputs.bind(this), this.mutatingVariableInputsLength());
    _o.intermediates =
        this.bb!.createScalarList(this.intermediates.bind(this), this.intermediatesLength());
  }
}

export class OperatorT {
  constructor(
      public opcodeIndex: number = 0, public inputs: (number)[] = [],
      public outputs: (number)[] = [],
      public builtinOptionsType: BuiltinOptions = BuiltinOptions.NONE,
      public builtinOptions: AbsOptionsT|AddNOptionsT|AddOptionsT|ArgMaxOptionsT|ArgMinOptionsT|
      AssignVariableOptionsT|BCQFullyConnectedOptionsT|BCQGatherOptionsT|BatchMatMulOptionsT|
      BatchToSpaceNDOptionsT|BidirectionalSequenceLSTMOptionsT|BidirectionalSequenceRNNOptionsT|
      BroadcastToOptionsT|CallOnceOptionsT|CallOptionsT|CastOptionsT|ConcatEmbeddingsOptionsT|
      ConcatenationOptionsT|Conv2DOptionsT|Conv3DOptionsT|CosOptionsT|CumsumOptionsT|
      DensifyOptionsT|DepthToSpaceOptionsT|DepthwiseConv2DOptionsT|DequantizeOptionsT|DivOptionsT|
      EmbeddingLookupSparseOptionsT|EqualOptionsT|ExpOptionsT|ExpandDimsOptionsT|FakeQuantOptionsT|
      FillOptionsT|FloorDivOptionsT|FloorModOptionsT|FullyConnectedOptionsT|GatherNdOptionsT|
      GatherOptionsT|GreaterEqualOptionsT|GreaterOptionsT|HardSwishOptionsT|HashtableFindOptionsT|
      HashtableImportOptionsT|HashtableOptionsT|HashtableSizeOptionsT|IfOptionsT|
      InstanceNormOptionsT|L2NormOptionsT|LSHProjectionOptionsT|LSTMOptionsT|LeakyReluOptionsT|
      LessEqualOptionsT|LessOptionsT|LocalResponseNormalizationOptionsT|LogSoftmaxOptionsT|
      LogicalAndOptionsT|LogicalNotOptionsT|LogicalOrOptionsT|MatrixDiagOptionsT|
      MatrixSetDiagOptionsT|MaximumMinimumOptionsT|MirrorPadOptionsT|MulOptionsT|NegOptionsT|
      NonMaxSuppressionV4OptionsT|NonMaxSuppressionV5OptionsT|NotEqualOptionsT|OneHotOptionsT|
      PackOptionsT|PadOptionsT|PadV2OptionsT|Pool2DOptionsT|PowOptionsT|QuantizeOptionsT|
      RNNOptionsT|RandomOptionsT|RangeOptionsT|RankOptionsT|ReadVariableOptionsT|ReducerOptionsT|
      ReshapeOptionsT|ResizeBilinearOptionsT|ResizeNearestNeighborOptionsT|ReverseSequenceOptionsT|
      ReverseV2OptionsT|Rfft2dOptionsT|SVDFOptionsT|ScatterNdOptionsT|SegmentSumOptionsT|
      SelectOptionsT|SelectV2OptionsT|SequenceRNNOptionsT|ShapeOptionsT|SkipGramOptionsT|
      SliceOptionsT|SoftmaxOptionsT|SpaceToBatchNDOptionsT|SpaceToDepthOptionsT|
      SparseToDenseOptionsT|SplitOptionsT|SplitVOptionsT|SquareOptionsT|SquaredDifferenceOptionsT|
      SqueezeOptionsT|StridedSliceOptionsT|SubOptionsT|TileOptionsT|TopKV2OptionsT|
      TransposeConvOptionsT|TransposeOptionsT|UnidirectionalSequenceLSTMOptionsT|UniqueOptionsT|
      UnpackOptionsT|VarHandleOptionsT|WhereOptionsT|WhileOptionsT|ZerosLikeOptionsT|null = null,
      public customOptions: (number)[] = [],
      public customOptionsFormat: CustomOptionsFormat = CustomOptionsFormat.FLEXBUFFERS,
      public mutatingVariableInputs: (boolean)[] = [], public intermediates: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const inputs = Operator.createInputsVector(builder, this.inputs);
    const outputs = Operator.createOutputsVector(builder, this.outputs);
    const builtinOptions = builder.createObjectOffset(this.builtinOptions);
    const customOptions = Operator.createCustomOptionsVector(builder, this.customOptions);
    const mutatingVariableInputs =
        Operator.createMutatingVariableInputsVector(builder, this.mutatingVariableInputs);
    const intermediates = Operator.createIntermediatesVector(builder, this.intermediates);

    return Operator.createOperator(
        builder, this.opcodeIndex, inputs, outputs, this.builtinOptionsType, builtinOptions,
        customOptions, this.customOptionsFormat, mutatingVariableInputs, intermediates);
  }
}

export class SubGraph {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SubGraph {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSubGraph(bb: flatbuffers.ByteBuffer, obj?: SubGraph): SubGraph {
    return (obj || new SubGraph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSubGraph(bb: flatbuffers.ByteBuffer, obj?: SubGraph): SubGraph {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SubGraph()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  tensors(index: number, obj?: Tensor): Tensor|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ?
        (obj || new Tensor())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  tensorsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  inputs(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  inputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  inputsArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  outputs(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  outputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  outputsArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  operators(index: number, obj?: Operator): Operator|null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ?
        (obj || new Operator())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  operatorsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  name(): string|null
  name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  name(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  dataFormat(): DataFormat {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt8(this.bb_pos + offset) : DataFormat.CHANNELS_LAST;
  }

  static startSubGraph(builder: flatbuffers.Builder) {
    builder.startObject(6);
  }

  static addTensors(builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, tensorsOffset, 0);
  }

  static createTensorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startTensorsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, inputsOffset, 0);
  }

  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createInputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startInputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, outputsOffset, 0);
  }

  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createOutputsVector(builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addOperators(builder: flatbuffers.Builder, operatorsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, operatorsOffset, 0);
  }

  static createOperatorsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startOperatorsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(4, nameOffset, 0);
  }

  static addDataFormat(builder: flatbuffers.Builder, dataFormat: DataFormat) {
    builder.addFieldInt8(5, dataFormat, DataFormat.CHANNELS_LAST);
  }

  static endSubGraph(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSubGraph(
      builder: flatbuffers.Builder, tensorsOffset: flatbuffers.Offset,
      inputsOffset: flatbuffers.Offset, outputsOffset: flatbuffers.Offset,
      operatorsOffset: flatbuffers.Offset, nameOffset: flatbuffers.Offset,
      dataFormat: DataFormat): flatbuffers.Offset {
    SubGraph.startSubGraph(builder);
    SubGraph.addTensors(builder, tensorsOffset);
    SubGraph.addInputs(builder, inputsOffset);
    SubGraph.addOutputs(builder, outputsOffset);
    SubGraph.addOperators(builder, operatorsOffset);
    SubGraph.addName(builder, nameOffset);
    SubGraph.addDataFormat(builder, dataFormat);
    return SubGraph.endSubGraph(builder);
  }

  unpack(): SubGraphT {
    return new SubGraphT(
        this.bb!.createObjList(this.tensors.bind(this), this.tensorsLength()),
        this.bb!.createScalarList(this.inputs.bind(this), this.inputsLength()),
        this.bb!.createScalarList(this.outputs.bind(this), this.outputsLength()),
        this.bb!.createObjList(this.operators.bind(this), this.operatorsLength()), this.name(),
        this.dataFormat());
  }


  unpackTo(_o: SubGraphT): void {
    _o.tensors = this.bb!.createObjList(this.tensors.bind(this), this.tensorsLength());
    _o.inputs = this.bb!.createScalarList(this.inputs.bind(this), this.inputsLength());
    _o.outputs = this.bb!.createScalarList(this.outputs.bind(this), this.outputsLength());
    _o.operators = this.bb!.createObjList(this.operators.bind(this), this.operatorsLength());
    _o.name = this.name();
    _o.dataFormat = this.dataFormat();
  }
}

export class SubGraphT {
  constructor(
      public tensors: (TensorT)[] = [], public inputs: (number)[] = [],
      public outputs: (number)[] = [], public operators: (OperatorT)[] = [],
      public name: string|Uint8Array|null = null,
      public dataFormat: DataFormat = DataFormat.CHANNELS_LAST) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const tensors =
        SubGraph.createTensorsVector(builder, builder.createObjectOffsetList(this.tensors));
    const inputs = SubGraph.createInputsVector(builder, this.inputs);
    const outputs = SubGraph.createOutputsVector(builder, this.outputs);
    const operators =
        SubGraph.createOperatorsVector(builder, builder.createObjectOffsetList(this.operators));
    const name = (this.name !== null ? builder.createString(this.name!) : 0);

    return SubGraph.createSubGraph(
        builder, tensors, inputs, outputs, operators, name, this.dataFormat);
  }
}

export class Buffer {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Buffer {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsBuffer(bb: flatbuffers.ByteBuffer, obj?: Buffer): Buffer {
    return (obj || new Buffer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsBuffer(bb: flatbuffers.ByteBuffer, obj?: Buffer): Buffer {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Buffer()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  data(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint8(this.bb!.__vector(this.bb_pos + offset) + index) : 0;
  }

  dataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  dataArray(): Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? new Uint8Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  static startBuffer(builder: flatbuffers.Builder) {
    builder.startObject(1);
  }

  static addData(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, dataOffset, 0);
  }

  static createDataVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset {
    builder.startVector(1, data.length, 1);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt8(data[i]!);
    }
    return builder.endVector();
  }

  static startDataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(1, numElems, 1);
  }

  static endBuffer(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createBuffer(builder: flatbuffers.Builder, dataOffset: flatbuffers.Offset):
      flatbuffers.Offset {
    Buffer.startBuffer(builder);
    Buffer.addData(builder, dataOffset);
    return Buffer.endBuffer(builder);
  }

  unpack(): BufferT {
    return new BufferT(this.bb!.createScalarList(this.data.bind(this), this.dataLength()));
  }


  unpackTo(_o: BufferT): void {
    _o.data = this.bb!.createScalarList(this.data.bind(this), this.dataLength());
  }
}

export class BufferT {
  constructor(public data: (number)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const data = Buffer.createDataVector(builder, this.data);

    return Buffer.createBuffer(builder, data);
  }
}

export class Metadata {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Metadata {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsMetadata(bb: flatbuffers.ByteBuffer, obj?: Metadata): Metadata {
    return (obj || new Metadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsMetadata(bb: flatbuffers.ByteBuffer, obj?: Metadata): Metadata {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Metadata()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  name(): string|null
  name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  name(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  buffer(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  static startMetadata(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }

  static addBuffer(builder: flatbuffers.Builder, buffer: number) {
    builder.addFieldInt32(1, buffer, 0);
  }

  static endMetadata(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createMetadata(
      builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset,
      buffer: number): flatbuffers.Offset {
    Metadata.startMetadata(builder);
    Metadata.addName(builder, nameOffset);
    Metadata.addBuffer(builder, buffer);
    return Metadata.endMetadata(builder);
  }

  unpack(): MetadataT {
    return new MetadataT(this.name(), this.buffer());
  }


  unpackTo(_o: MetadataT): void {
    _o.name = this.name();
    _o.buffer = this.buffer();
  }
}

export class MetadataT {
  constructor(public name: string|Uint8Array|null = null, public buffer: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const name = (this.name !== null ? builder.createString(this.name!) : 0);

    return Metadata.createMetadata(builder, name, this.buffer);
  }
}

export class TensorMap {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): TensorMap {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsTensorMap(bb: flatbuffers.ByteBuffer, obj?: TensorMap): TensorMap {
    return (obj || new TensorMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsTensorMap(bb: flatbuffers.ByteBuffer, obj?: TensorMap): TensorMap {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new TensorMap()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  name(): string|null
  name(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  name(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  tensorIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  static startTensorMap(builder: flatbuffers.Builder) {
    builder.startObject(2);
  }

  static addName(builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, nameOffset, 0);
  }

  static addTensorIndex(builder: flatbuffers.Builder, tensorIndex: number) {
    builder.addFieldInt32(1, tensorIndex, 0);
  }

  static endTensorMap(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createTensorMap(
      builder: flatbuffers.Builder, nameOffset: flatbuffers.Offset,
      tensorIndex: number): flatbuffers.Offset {
    TensorMap.startTensorMap(builder);
    TensorMap.addName(builder, nameOffset);
    TensorMap.addTensorIndex(builder, tensorIndex);
    return TensorMap.endTensorMap(builder);
  }

  unpack(): TensorMapT {
    return new TensorMapT(this.name(), this.tensorIndex());
  }


  unpackTo(_o: TensorMapT): void {
    _o.name = this.name();
    _o.tensorIndex = this.tensorIndex();
  }
}

export class TensorMapT {
  constructor(public name: string|Uint8Array|null = null, public tensorIndex: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const name = (this.name !== null ? builder.createString(this.name!) : 0);

    return TensorMap.createTensorMap(builder, name, this.tensorIndex);
  }
}

export class SignatureDef {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): SignatureDef {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsSignatureDef(bb: flatbuffers.ByteBuffer, obj?: SignatureDef): SignatureDef {
    return (obj || new SignatureDef()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsSignatureDef(bb: flatbuffers.ByteBuffer, obj?: SignatureDef):
      SignatureDef {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new SignatureDef()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  inputs(index: number, obj?: TensorMap): TensorMap|null {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ?
        (obj || new TensorMap())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  inputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  outputs(index: number, obj?: TensorMap): TensorMap|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ?
        (obj || new TensorMap())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  outputsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  signatureKey(): string|null
  signatureKey(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  signatureKey(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  subgraphIndex(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  static startSignatureDef(builder: flatbuffers.Builder) {
    builder.startObject(5);
  }

  static addInputs(builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(0, inputsOffset, 0);
  }

  static createInputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startInputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addOutputs(builder: flatbuffers.Builder, outputsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, outputsOffset, 0);
  }

  static createOutputsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startOutputsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addSignatureKey(builder: flatbuffers.Builder, signatureKeyOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, signatureKeyOffset, 0);
  }

  static addSubgraphIndex(builder: flatbuffers.Builder, subgraphIndex: number) {
    builder.addFieldInt32(4, subgraphIndex, 0);
  }

  static endSignatureDef(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static createSignatureDef(
      builder: flatbuffers.Builder, inputsOffset: flatbuffers.Offset,
      outputsOffset: flatbuffers.Offset, signatureKeyOffset: flatbuffers.Offset,
      subgraphIndex: number): flatbuffers.Offset {
    SignatureDef.startSignatureDef(builder);
    SignatureDef.addInputs(builder, inputsOffset);
    SignatureDef.addOutputs(builder, outputsOffset);
    SignatureDef.addSignatureKey(builder, signatureKeyOffset);
    SignatureDef.addSubgraphIndex(builder, subgraphIndex);
    return SignatureDef.endSignatureDef(builder);
  }

  unpack(): SignatureDefT {
    return new SignatureDefT(
        this.bb!.createObjList(this.inputs.bind(this), this.inputsLength()),
        this.bb!.createObjList(this.outputs.bind(this), this.outputsLength()), this.signatureKey(),
        this.subgraphIndex());
  }


  unpackTo(_o: SignatureDefT): void {
    _o.inputs = this.bb!.createObjList(this.inputs.bind(this), this.inputsLength());
    _o.outputs = this.bb!.createObjList(this.outputs.bind(this), this.outputsLength());
    _o.signatureKey = this.signatureKey();
    _o.subgraphIndex = this.subgraphIndex();
  }
}

export class SignatureDefT {
  constructor(
      public inputs: (TensorMapT)[] = [], public outputs: (TensorMapT)[] = [],
      public signatureKey: string|Uint8Array|null = null, public subgraphIndex: number = 0) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const inputs =
        SignatureDef.createInputsVector(builder, builder.createObjectOffsetList(this.inputs));
    const outputs =
        SignatureDef.createOutputsVector(builder, builder.createObjectOffsetList(this.outputs));
    const signatureKey =
        (this.signatureKey !== null ? builder.createString(this.signatureKey!) : 0);

    return SignatureDef.createSignatureDef(
        builder, inputs, outputs, signatureKey, this.subgraphIndex);
  }
}

export class Model {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i: number, bb: flatbuffers.ByteBuffer): Model {
    this.bb_pos = i;
    this.bb = bb;
    return this;
  }

  static getRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {
    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static getSizePrefixedRootAsModel(bb: flatbuffers.ByteBuffer, obj?: Model): Model {
    bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
    return (obj || new Model()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
  }

  static bufferHasIdentifier(bb: flatbuffers.ByteBuffer): boolean {
    return bb.__has_identifier('CIR0');
  }

  version(): number {
    const offset = this.bb!.__offset(this.bb_pos, 4);
    return offset ? this.bb!.readUint32(this.bb_pos + offset) : 0;
  }

  operatorCodes(index: number, obj?: OperatorCode): OperatorCode|null {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ?
        (obj || new OperatorCode())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  operatorCodesLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 6);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  subgraphs(index: number, obj?: SubGraph): SubGraph|null {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ?
        (obj || new SubGraph())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  subgraphsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 8);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  description(): string|null
  description(optionalEncoding: flatbuffers.Encoding): string|Uint8Array|null
  description(optionalEncoding?: any): string|Uint8Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 10);
    return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
  }

  buffers(index: number, obj?: Buffer): Buffer|null {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ?
        (obj || new Buffer())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  buffersLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 12);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  metadataBuffer(index: number): number|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
  }

  metadataBufferLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  metadataBufferArray(): Int32Array|null {
    const offset = this.bb!.__offset(this.bb_pos, 14);
    return offset ? new Int32Array(
                        this.bb!.bytes().buffer,
                        this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset),
                        this.bb!.__vector_len(this.bb_pos + offset)) :
                    null;
  }

  metadata(index: number, obj?: Metadata): Metadata|null {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ?
        (obj || new Metadata())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  metadataLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 16);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  signatureDefs(index: number, obj?: SignatureDef): SignatureDef|null {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ?
        (obj || new SignatureDef())
            .__init(
                this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!
                ) :
        null;
  }

  signatureDefsLength(): number {
    const offset = this.bb!.__offset(this.bb_pos, 18);
    return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
  }

  static startModel(builder: flatbuffers.Builder) {
    builder.startObject(8);
  }

  static addVersion(builder: flatbuffers.Builder, version: number) {
    builder.addFieldInt32(0, version, 0);
  }

  static addOperatorCodes(builder: flatbuffers.Builder, operatorCodesOffset: flatbuffers.Offset) {
    builder.addFieldOffset(1, operatorCodesOffset, 0);
  }

  static createOperatorCodesVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startOperatorCodesVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addSubgraphs(builder: flatbuffers.Builder, subgraphsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(2, subgraphsOffset, 0);
  }

  static createSubgraphsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startSubgraphsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addDescription(builder: flatbuffers.Builder, descriptionOffset: flatbuffers.Offset) {
    builder.addFieldOffset(3, descriptionOffset, 0);
  }

  static addBuffers(builder: flatbuffers.Builder, buffersOffset: flatbuffers.Offset) {
    builder.addFieldOffset(4, buffersOffset, 0);
  }

  static createBuffersVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startBuffersVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addMetadataBuffer(builder: flatbuffers.Builder, metadataBufferOffset: flatbuffers.Offset) {
    builder.addFieldOffset(5, metadataBufferOffset, 0);
  }

  static createMetadataBufferVector(builder: flatbuffers.Builder, data: number[]|Int32Array):
      flatbuffers.Offset;
  /**
   * @deprecated This Uint8Array overload will be removed in the future.
   */
  static createMetadataBufferVector(builder: flatbuffers.Builder, data: number[]|Uint8Array):
      flatbuffers.Offset;
  static createMetadataBufferVector(
      builder: flatbuffers.Builder, data: number[]|Int32Array|Uint8Array): flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addInt32(data[i]!);
    }
    return builder.endVector();
  }

  static startMetadataBufferVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addMetadata(builder: flatbuffers.Builder, metadataOffset: flatbuffers.Offset) {
    builder.addFieldOffset(6, metadataOffset, 0);
  }

  static createMetadataVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startMetadataVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static addSignatureDefs(builder: flatbuffers.Builder, signatureDefsOffset: flatbuffers.Offset) {
    builder.addFieldOffset(7, signatureDefsOffset, 0);
  }

  static createSignatureDefsVector(builder: flatbuffers.Builder, data: flatbuffers.Offset[]):
      flatbuffers.Offset {
    builder.startVector(4, data.length, 4);
    for (let i = data.length - 1; i >= 0; i--) {
      builder.addOffset(data[i]!);
    }
    return builder.endVector();
  }

  static startSignatureDefsVector(builder: flatbuffers.Builder, numElems: number) {
    builder.startVector(4, numElems, 4);
  }

  static endModel(builder: flatbuffers.Builder): flatbuffers.Offset {
    const offset = builder.endObject();
    return offset;
  }

  static finishModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset, 'CIR0');
  }

  static finishSizePrefixedModelBuffer(builder: flatbuffers.Builder, offset: flatbuffers.Offset) {
    builder.finish(offset, 'CIR0', true);
  }

  static createModel(
      builder: flatbuffers.Builder, version: number, operatorCodesOffset: flatbuffers.Offset,
      subgraphsOffset: flatbuffers.Offset, descriptionOffset: flatbuffers.Offset,
      buffersOffset: flatbuffers.Offset, metadataBufferOffset: flatbuffers.Offset,
      metadataOffset: flatbuffers.Offset,
      signatureDefsOffset: flatbuffers.Offset): flatbuffers.Offset {
    Model.startModel(builder);
    Model.addVersion(builder, version);
    Model.addOperatorCodes(builder, operatorCodesOffset);
    Model.addSubgraphs(builder, subgraphsOffset);
    Model.addDescription(builder, descriptionOffset);
    Model.addBuffers(builder, buffersOffset);
    Model.addMetadataBuffer(builder, metadataBufferOffset);
    Model.addMetadata(builder, metadataOffset);
    Model.addSignatureDefs(builder, signatureDefsOffset);
    return Model.endModel(builder);
  }

  unpack(): ModelT {
    return new ModelT(
        this.version(),
        this.bb!.createObjList(this.operatorCodes.bind(this), this.operatorCodesLength()),
        this.bb!.createObjList(this.subgraphs.bind(this), this.subgraphsLength()),
        this.description(), this.bb!.createObjList(this.buffers.bind(this), this.buffersLength()),
        this.bb!.createScalarList(this.metadataBuffer.bind(this), this.metadataBufferLength()),
        this.bb!.createObjList(this.metadata.bind(this), this.metadataLength()),
        this.bb!.createObjList(this.signatureDefs.bind(this), this.signatureDefsLength()));
  }


  unpackTo(_o: ModelT): void {
    _o.version = this.version();
    _o.operatorCodes =
        this.bb!.createObjList(this.operatorCodes.bind(this), this.operatorCodesLength());
    _o.subgraphs = this.bb!.createObjList(this.subgraphs.bind(this), this.subgraphsLength());
    _o.description = this.description();
    _o.buffers = this.bb!.createObjList(this.buffers.bind(this), this.buffersLength());
    _o.metadataBuffer =
        this.bb!.createScalarList(this.metadataBuffer.bind(this), this.metadataBufferLength());
    _o.metadata = this.bb!.createObjList(this.metadata.bind(this), this.metadataLength());
    _o.signatureDefs =
        this.bb!.createObjList(this.signatureDefs.bind(this), this.signatureDefsLength());
  }
}

export class ModelT {
  constructor(
      public version: number = 0, public operatorCodes: (OperatorCodeT)[] = [],
      public subgraphs: (SubGraphT)[] = [], public description: string|Uint8Array|null = null,
      public buffers: (BufferT)[] = [], public metadataBuffer: (number)[] = [],
      public metadata: (MetadataT)[] = [], public signatureDefs: (SignatureDefT)[] = []) {}


  pack(builder: flatbuffers.Builder): flatbuffers.Offset {
    const operatorCodes = Model.createOperatorCodesVector(
        builder, builder.createObjectOffsetList(this.operatorCodes));
    const subgraphs =
        Model.createSubgraphsVector(builder, builder.createObjectOffsetList(this.subgraphs));
    const description = (this.description !== null ? builder.createString(this.description!) : 0);
    const buffers =
        Model.createBuffersVector(builder, builder.createObjectOffsetList(this.buffers));
    const metadataBuffer = Model.createMetadataBufferVector(builder, this.metadataBuffer);
    const metadata =
        Model.createMetadataVector(builder, builder.createObjectOffsetList(this.metadata));
    const signatureDefs = Model.createSignatureDefsVector(
        builder, builder.createObjectOffsetList(this.signatureDefs));

    return Model.createModel(
        builder, this.version, operatorCodes, subgraphs, description, buffers, metadataBuffer,
        metadata, signatureDefs);
  }
}
